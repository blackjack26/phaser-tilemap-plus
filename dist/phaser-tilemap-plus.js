/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!********************************!*\
  !*** ./tilemap-plus/Vector.js ***!
  \********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Vector = function () {\n    function Vector(x, y) {\n        _classCallCheck(this, Vector);\n\n        this.x = x || 0;\n        this.y = y || 0;\n    }\n\n    _createClass(Vector, [{\n        key: \"clone\",\n        value: function clone() {\n            return new Vector(this.x, this.y);\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(vector) {\n            return vector && this.x === vector.x && this.y === vector.y;\n        }\n    }, {\n        key: \"length\",\n        value: function length() {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        }\n    }, {\n        key: \"normalized\",\n        value: function normalized() {\n            var len = this.length();\n            if (len === 0) {\n                return new Vector(0, 0);\n            } else {\n                return new Vector(this.x / len, this.y / len);\n            }\n        }\n    }, {\n        key: \"perpendicular\",\n        value: function perpendicular() {\n            return new Vector(-this.y, this.x);\n        }\n    }, {\n        key: \"rotated\",\n        value: function rotated(angle) {\n            var cos = Math.cos(angle);\n            var sin = Math.sin(angle);\n            return new Vector(cos * this.x + sin * this.y, -sin * this.x + cos * this.y);\n        }\n    }, {\n        key: \"plus\",\n        value: function plus(vector) {\n            return new Vector(this.x + vector.x, this.y + vector.y);\n        }\n    }, {\n        key: \"minus\",\n        value: function minus(vector) {\n            return new Vector(this.x - vector.x, this.y - vector.y);\n        }\n    }, {\n        key: \"dot\",\n        value: function dot(vector) {\n            return this.x * vector.x + this.y * vector.y;\n        }\n    }, {\n        key: \"perpDot\",\n        value: function perpDot(vector) {\n            return this.x * vector.y - this.y * vector.x;\n        }\n    }, {\n        key: \"scale\",\n        value: function scale(factor) {\n            return new Vector(this.x * factor, this.y * factor);\n        }\n    }]);\n\n    return Vector;\n}();\n\nexports.default = Vector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdGlsZW1hcC1wbHVzL1ZlY3Rvci5qcz83YmU4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih4LCB5KSB7XHJcbiAgICAgICAgdGhpcy54ID0geCB8fCAwO1xyXG4gICAgICAgIHRoaXMueSA9IHkgfHwgMDtcclxuICAgIH1cclxuXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLngsIHRoaXMueSk7XHJcbiAgICB9XHJcblxyXG4gICAgZXF1YWxzKHZlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiB2ZWN0b3IgJiYgdGhpcy54ID09PSB2ZWN0b3IueCAmJiB0aGlzLnkgPT09IHZlY3Rvci55O1xyXG4gICAgfVxyXG5cclxuICAgIGxlbmd0aCgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSlcclxuICAgIH1cclxuXHJcbiAgICBub3JtYWxpemVkKCkge1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoKCk7XHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCAwKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCAvIGxlbiwgdGhpcy55IC8gbGVuKTtcclxuICAgICAgICB9XHJcbiAgICB9ICAgIFxyXG5cclxuICAgIHBlcnBlbmRpY3VsYXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoLXRoaXMueSwgdGhpcy54KTtcclxuICAgIH1cclxuXHJcbiAgICByb3RhdGVkKGFuZ2xlKSB7XHJcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcihjb3MgKiB0aGlzLnggKyBzaW4gKiB0aGlzLnksIC1zaW4gKiB0aGlzLnggKyBjb3MgKiB0aGlzLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHBsdXModmVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54ICsgdmVjdG9yLngsIHRoaXMueSArIHZlY3Rvci55KTtcclxuICAgIH1cclxuXHJcbiAgICBtaW51cyh2ZWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnggLSB2ZWN0b3IueCwgdGhpcy55IC0gdmVjdG9yLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIGRvdCh2ZWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy54ICogdmVjdG9yLnggKyB0aGlzLnkgKiB2ZWN0b3IueTtcclxuICAgIH1cclxuXHJcbiAgICBwZXJwRG90KHZlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnggKiB2ZWN0b3IueSAtIHRoaXMueSAqIHZlY3Rvci54O1xyXG4gICAgfVxyXG5cclxuICAgIHNjYWxlKGZhY3Rvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCAqIGZhY3RvciwgdGhpcy55ICogZmFjdG9yKTtcclxuICAgIH0gICAgXHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RpbGVtYXAtcGx1cy9WZWN0b3IuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUF2REEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/*!*******************************!*\
  !*** ./tilemap-plus/Range.js ***!
  \*******************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Range = function () {\n    function Range() {\n        _classCallCheck(this, Range);\n\n        this.makeEmpty();\n    }\n\n    _createClass(Range, [{\n        key: \"extendTo\",\n        value: function extendTo(point) {\n            if (this.min > point) {\n                this.min = point;\n            }\n            if (this.max < point) {\n                this.max = point;\n            }\n        }\n    }, {\n        key: \"containsPoint\",\n        value: function containsPoint(point) {\n            return this.min <= point && point <= this.max;\n        }\n    }, {\n        key: \"containsRange\",\n        value: function containsRange(range) {\n            return this.min <= range.min && this.max > range.max;\n        }\n    }, {\n        key: \"isEmpty\",\n        value: function isEmpty() {\n            return this.min > this.max;\n        }\n    }, {\n        key: \"makeEmpty\",\n        value: function makeEmpty() {\n            this.min = Number.POSITIVE_INFINITY;\n            this.max = Number.NEGATIVE_INFINITY;\n        }\n    }, {\n        key: \"length\",\n        value: function length() {\n            if (this.min > this.max) {\n                return Number.NaN;\n            }\n            return this.max - this.min;\n        }\n    }], [{\n        key: \"intersection\",\n        value: function intersection(r1, r2) {\n            var range = new Range();\n            range.min = Math.max(r1.min, r2.min);\n            range.max = Math.min(r1.max, r2.max);\n            if (range.min > range.max) {\n                range.makeEmpty();\n            }\n            return range;\n        }\n    }, {\n        key: \"bound\",\n        value: function bound(r1, r2) {\n            var range = new Range();\n            range.min = Math.min(r1.min, r2.min);\n            range.max = Math.max(r1.max, r2.max);\n            return range;\n        }\n    }]);\n\n    return Range;\n}();\n\nexports.default = Range;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdGlsZW1hcC1wbHVzL1JhbmdlLmpzPzU3ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFuZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5tYWtlRW1wdHkoKTtcclxuICAgIH1cclxuXHJcbiAgICBleHRlbmRUbyhwb2ludCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1pbiA+IHBvaW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMubWluID0gcG9pbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1heCA8IHBvaW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gcG9pbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taW4gPD0gcG9pbnQgJiYgcG9pbnQgPD0gdGhpcy5tYXg7XHJcbiAgICB9XHJcblxyXG4gICAgY29udGFpbnNSYW5nZShyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1pbiA8PSByYW5nZS5taW4gJiYgdGhpcy5tYXggPiByYW5nZS5tYXg7XHJcbiAgICB9XHJcblxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taW4gPiB0aGlzLm1heDtcclxuICAgIH1cclxuXHJcbiAgICBtYWtlRW1wdHkoKSB7XHJcbiAgICAgICAgdGhpcy5taW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgICAgdGhpcy5tYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XHJcbiAgICB9XHJcblxyXG4gICAgbGVuZ3RoKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1pbiA+IHRoaXMubWF4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTmFOO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5tYXggLSB0aGlzLm1pbjtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgaW50ZXJzZWN0aW9uKHIxLCByMikge1xyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gbmV3IFJhbmdlKCk7XHJcbiAgICAgICAgcmFuZ2UubWluID0gTWF0aC5tYXgocjEubWluLCByMi5taW4pO1xyXG4gICAgICAgIHJhbmdlLm1heCA9IE1hdGgubWluKHIxLm1heCwgcjIubWF4KTtcclxuICAgICAgICBpZiAocmFuZ2UubWluID4gcmFuZ2UubWF4KSB7XHJcbiAgICAgICAgICAgIHJhbmdlLm1ha2VFbXB0eSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmFuZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGJvdW5kKHIxLCByMikge1xyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gbmV3IFJhbmdlKCk7XHJcbiAgICAgICAgcmFuZ2UubWluID0gTWF0aC5taW4ocjEubWluLCByMi5taW4pO1xyXG4gICAgICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHIxLm1heCwgcjIubWF4KTtcclxuICAgICAgICByZXR1cm4gcmFuZ2U7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RpbGVtYXAtcGx1cy9SYW5nZS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBckRBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _TilemapPlus = __webpack_require__(/*! ./tilemap-plus/TilemapPlus */ 3);\n\nvar _TilemapPlus2 = _interopRequireDefault(_TilemapPlus);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nPhaser.Plugin.TilemapPlus = function (game, parent) {\n    Phaser.Plugin.call(this, game, parent);\n\n    var originalTilemapLoader = Phaser.Loader.prototype.tilemap;\n    Phaser.Loader.prototype.tilemap = function (key, url, data, format) {\n        originalTilemapLoader.call(this, key, url, data, format);\n        this.json(jsonKey(key), url);\n    };\n\n    var originalTilemapFactory = Phaser.GameObjectFactory.prototype.tilemap;\n    Phaser.GameObjectFactory.prototype.tilemap = function (key, tileWidth, tileHeight, width, height) {\n        var tilemap = originalTilemapFactory.call(this, key, tileWidth, tileHeight, width, height);\n        var tilemapJson = this.game.cache.getJSON(jsonKey(key));\n        tilemap.plus = new _TilemapPlus2.default(tilemapJson, this.game.time, tilemap);\n        return tilemap;\n    };\n\n    var originalSpriteFactory = Phaser.GameObjectFactory.prototype.sprite;\n    Phaser.GameObjectFactory.prototype.sprite = function (x, y, key, frame, group) {\n        var sprite = originalSpriteFactory.call(this, x, y, key, frame, group);\n        sprite.plus = {};\n        return sprite;\n    };\n\n    function jsonKey(key) {\n        return key + \"-TilemapPlus\";\n    }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvaW5kZXguanM/MWZkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVGlsZW1hcFBsdXMgZnJvbSBcIi4vdGlsZW1hcC1wbHVzL1RpbGVtYXBQbHVzXCI7XHJcblxyXG5QaGFzZXIuUGx1Z2luLlRpbGVtYXBQbHVzID0gZnVuY3Rpb24gKGdhbWUsIHBhcmVudCkge1xyXG5cdFBoYXNlci5QbHVnaW4uY2FsbCh0aGlzLCBnYW1lLCBwYXJlbnQpO1xyXG4gICAgXHJcbiAgICBjb25zdCBvcmlnaW5hbFRpbGVtYXBMb2FkZXIgPSBQaGFzZXIuTG9hZGVyLnByb3RvdHlwZS50aWxlbWFwO1xyXG4gICAgUGhhc2VyLkxvYWRlci5wcm90b3R5cGUudGlsZW1hcCA9IGZ1bmN0aW9uKGtleSwgdXJsLCBkYXRhLCBmb3JtYXQpIHtcclxuICAgICAgICBvcmlnaW5hbFRpbGVtYXBMb2FkZXIuY2FsbCh0aGlzLCBrZXksIHVybCwgZGF0YSwgZm9ybWF0KTtcclxuICAgICAgICB0aGlzLmpzb24oanNvbktleShrZXkpLCB1cmwpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgY29uc3Qgb3JpZ2luYWxUaWxlbWFwRmFjdG9yeSA9IFBoYXNlci5HYW1lT2JqZWN0RmFjdG9yeS5wcm90b3R5cGUudGlsZW1hcDtcclxuICAgIFBoYXNlci5HYW1lT2JqZWN0RmFjdG9yeS5wcm90b3R5cGUudGlsZW1hcCA9IGZ1bmN0aW9uKGtleSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgY29uc3QgdGlsZW1hcCA9IG9yaWdpbmFsVGlsZW1hcEZhY3RvcnkuY2FsbCh0aGlzLCBrZXksIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgY29uc3QgdGlsZW1hcEpzb24gPSB0aGlzLmdhbWUuY2FjaGUuZ2V0SlNPTihqc29uS2V5KGtleSkpOyBcclxuICAgICAgICB0aWxlbWFwLnBsdXMgPSBuZXcgVGlsZW1hcFBsdXModGlsZW1hcEpzb24sIHRoaXMuZ2FtZS50aW1lLCB0aWxlbWFwKTtcclxuICAgICAgICByZXR1cm4gdGlsZW1hcDtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3Qgb3JpZ2luYWxTcHJpdGVGYWN0b3J5ID0gUGhhc2VyLkdhbWVPYmplY3RGYWN0b3J5LnByb3RvdHlwZS5zcHJpdGU7XHJcbiAgICBQaGFzZXIuR2FtZU9iamVjdEZhY3RvcnkucHJvdG90eXBlLnNwcml0ZSA9IGZ1bmN0aW9uKHgsIHksIGtleSwgZnJhbWUsIGdyb3VwKSB7XHJcbiAgICAgICAgY29uc3Qgc3ByaXRlID0gb3JpZ2luYWxTcHJpdGVGYWN0b3J5LmNhbGwodGhpcywgeCwgeSwga2V5LCBmcmFtZSwgZ3JvdXApO1xyXG4gICAgICAgIHNwcml0ZS5wbHVzID0ge307XHJcbiAgICAgICAgcmV0dXJuIHNwcml0ZTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24ganNvbktleShrZXkpIHtcclxuICAgICAgICByZXR1cm4ga2V5ICsgXCItVGlsZW1hcFBsdXNcIjtcclxuICAgIH1cclxufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/*!*************************************!*\
  !*** ./tilemap-plus/TilemapPlus.js ***!
  \*************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _Animation = __webpack_require__(/*! ./Animation */ 4);\n\nvar _Animation2 = _interopRequireDefault(_Animation);\n\nvar _Physics = __webpack_require__(/*! ./Physics */ 5);\n\nvar _Physics2 = _interopRequireDefault(_Physics);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TilemapPlus = function TilemapPlus(tilemapJson, time, tilemap) {\n    _classCallCheck(this, TilemapPlus);\n\n    this.tilemapJson = tilemapJson;\n    this.time = time;\n    this.tilemap = tilemap;\n    this.timer = null;\n    this.tileAnimations = [];\n    this.game = time.game;\n    this.animation = new _Animation2.default(tilemapJson, time, tilemap);\n    this.physics = new _Physics2.default(tilemapJson);\n};\n\nexports.default = TilemapPlus;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdGlsZW1hcC1wbHVzL1RpbGVtYXBQbHVzLmpzPzczODgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEFuaW1hdGlvbiBmcm9tIFwiLi9BbmltYXRpb25cIjtcclxuaW1wb3J0IFBoeXNpY3MgZnJvbSBcIi4vUGh5c2ljc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZW1hcFBsdXMge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHRpbGVtYXBKc29uLCB0aW1lLCB0aWxlbWFwKSB7XHJcbiAgICAgICAgdGhpcy50aWxlbWFwSnNvbiA9IHRpbGVtYXBKc29uO1xyXG4gICAgICAgIHRoaXMudGltZSA9IHRpbWU7XHJcbiAgICAgICAgdGhpcy50aWxlbWFwID0gdGlsZW1hcDtcclxuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRpbGVBbmltYXRpb25zID0gW107XHJcbiAgICAgICAgdGhpcy5nYW1lID0gdGltZS5nYW1lO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih0aWxlbWFwSnNvbiwgdGltZSwgdGlsZW1hcCk7XHJcbiAgICAgICAgdGhpcy5waHlzaWNzID0gbmV3IFBoeXNpY3ModGlsZW1hcEpzb24pO1xyXG4gICAgfSAgICBcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RpbGVtYXAtcGx1cy9UaWxlbWFwUGx1cy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7OztBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/*!***********************************!*\
  !*** ./tilemap-plus/Animation.js ***!
  \***********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TilemapPlusAnimation = function () {\n    function TilemapPlusAnimation(tilemapJson, time, tilemap) {\n        _classCallCheck(this, TilemapPlusAnimation);\n\n        this.tilemapJson = tilemapJson;\n        this.time = time;\n        this.tilemap = tilemap;\n        this.timer = null;\n        this.tileAnimations = [];\n        this.game = time.game;\n    }\n\n    _createClass(TilemapPlusAnimation, [{\n        key: \"enable\",\n        value: function enable() {\n            var _this = this;\n\n            if (this.timer == null) {\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = this.tilemapJson.tilesets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var tilesetJson = _step.value;\n\n                        if (tilesetJson.tiles) {\n                            _addAnimationsFromTileset.bind(this)(tilesetJson);\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n\n                this.timer = this.time.events.loop(20, function () {\n                    return _animate.bind(_this)();\n                });\n            }\n        }\n    }, {\n        key: \"disable\",\n        value: function disable() {\n            if (this.timer != null) {\n                this.time.events.remove(this.timer);\n                this.timer = null;\n                this.tileAnimations = [];\n            }\n        }\n    }]);\n\n    return TilemapPlusAnimation;\n}();\n\nexports.default = TilemapPlusAnimation;\n\n\nfunction _addAnimationsFromTileset(tilesetJson) {\n    var tilesJson = tilesetJson.tiles;\n    if (!tilesJson) {\n        return;\n    }\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n        for (var _iterator2 = Object.keys(tilesJson)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var animatedTileId = _step2.value;\n\n            var tileJson = tilesJson[animatedTileId];\n            var animationJson = tileJson.animation;\n            if (animationJson && animationJson.length > 0) {\n                _addAnimationsFromAnimatedTile.bind(this)(tilesetJson, animatedTileId, animationJson);\n            }\n        }\n    } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n            }\n        } finally {\n            if (_didIteratorError2) {\n                throw _iteratorError2;\n            }\n        }\n    }\n}\n\nfunction _addAnimationsFromAnimatedTile(tilesetJson, animatedTileId, animationJson) {\n    var tiles = animationJson.map(function (animationJson) {\n        return animationJson.tileid;\n    });\n\n    var frameInterval = animationJson.find(function () {\n        return true;\n    }).duration;\n    var tileset = this.tilemap.tilesets.find(function (t) {\n        return t.name === tilesetJson.name;\n    });\n\n    var tileAnimation = {\n        tiles: tiles,\n        frameInterval: frameInterval,\n        tileset: tileset,\n        tileLocations: _getTileLocations.bind(this)(tileset.firstgid + parseInt(animatedTileId)),\n        currentFrame: 0\n    };\n\n    this.tileAnimations.push(tileAnimation);\n}\n\nfunction _animate() {\n    var currentTime = this.time.now;\n    var dirty = false;\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n        for (var _iterator3 = this.tileAnimations[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var tileAnimation = _step3.value;\n\n            var tiles = tileAnimation.tiles;\n            var frameInterval = tileAnimation.frameInterval;\n            var tileset = tileAnimation.tileset;\n            var tileLocations = tileAnimation.tileLocations;\n            var currentFrame = tileAnimation.currentFrame;\n\n            var newFrame = Math.floor(currentTime / frameInterval) % tiles.length;\n            if (newFrame != currentFrame) {\n                var newFrameIndex = tileset.firstgid + tiles[newFrame];\n                var _iteratorNormalCompletion5 = true;\n                var _didIteratorError5 = false;\n                var _iteratorError5 = undefined;\n\n                try {\n                    for (var _iterator5 = tileLocations[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                        var tileLocation = _step5.value;\n\n                        var tile = this.tilemap.getTile(tileLocation.x, tileLocation.y, tileLocation.layer, true);\n                        tile.index = newFrameIndex;\n                    }\n                } catch (err) {\n                    _didIteratorError5 = true;\n                    _iteratorError5 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                            _iterator5.return();\n                        }\n                    } finally {\n                        if (_didIteratorError5) {\n                            throw _iteratorError5;\n                        }\n                    }\n                }\n\n                tileAnimation.currentFrame = newFrame;\n                dirty = true;\n            }\n        }\n    } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                _iterator3.return();\n            }\n        } finally {\n            if (_didIteratorError3) {\n                throw _iteratorError3;\n            }\n        }\n    }\n\n    if (dirty) {\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n            for (var _iterator4 = this.tilemap.layers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                var layer = _step4.value;\n\n                layer.dirty = true;\n            }\n        } catch (err) {\n            _didIteratorError4 = true;\n            _iteratorError4 = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                    _iterator4.return();\n                }\n            } finally {\n                if (_didIteratorError4) {\n                    throw _iteratorError4;\n                }\n            }\n        }\n    }\n}\n\nfunction _getTileLocations(animatedTileId) {\n    var tileLocations = [];\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n        for (var _iterator6 = this.tilemapJson.layers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var layerJson = _step6.value;\n\n            if (layerJson.type !== \"tilelayer\") {\n                continue;\n            }\n            var data = layerJson.data;\n            var width = layerJson.width;\n            var height = layerJson.height;\n            for (var y = 0; y < height; y++) {\n                for (var x = 0; x < width; x++) {\n                    if (data[y * width + x] === animatedTileId) {\n                        tileLocations.push({ x: x, y: y, layer: layerJson.name });\n                    }\n                }\n            }\n        }\n    } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                _iterator6.return();\n            }\n        } finally {\n            if (_didIteratorError6) {\n                throw _iteratorError6;\n            }\n        }\n    }\n\n    return tileLocations;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdGlsZW1hcC1wbHVzL0FuaW1hdGlvbi5qcz8zNjc3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGVtYXBQbHVzQW5pbWF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKHRpbGVtYXBKc29uLCB0aW1lLCB0aWxlbWFwKSB7XHJcbiAgICAgICAgdGhpcy50aWxlbWFwSnNvbiA9IHRpbGVtYXBKc29uO1xyXG4gICAgICAgIHRoaXMudGltZSA9IHRpbWU7XHJcbiAgICAgICAgdGhpcy50aWxlbWFwID0gdGlsZW1hcDtcclxuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRpbGVBbmltYXRpb25zID0gW107XHJcbiAgICAgICAgdGhpcy5nYW1lID0gdGltZS5nYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGVuYWJsZSgpIHtcclxuICAgICAgICBpZiAodGhpcy50aW1lciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGlsZXNldEpzb24gb2YgdGhpcy50aWxlbWFwSnNvbi50aWxlc2V0cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbGVzZXRKc29uLnRpbGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2FkZEFuaW1hdGlvbnNGcm9tVGlsZXNldC5iaW5kKHRoaXMpKHRpbGVzZXRKc29uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy50aW1lciA9IHRoaXMudGltZS5ldmVudHMubG9vcCgyMCwgKCkgPT4gX2FuaW1hdGUuYmluZCh0aGlzKSgpKTtcclxuICAgICAgICB9ICAgXHJcbiAgICB9XHJcblxyXG4gICAgZGlzYWJsZSgpIHtcclxuICAgICAgICBpZiAodGhpcy50aW1lciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZS5ldmVudHMucmVtb3ZlKHRoaXMudGltZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy50aWxlQW5pbWF0aW9ucyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIF9hZGRBbmltYXRpb25zRnJvbVRpbGVzZXQodGlsZXNldEpzb24pIHtcclxuICAgIGNvbnN0IHRpbGVzSnNvbiA9IHRpbGVzZXRKc29uLnRpbGVzO1xyXG4gICAgaWYgKCF0aWxlc0pzb24pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGFuaW1hdGVkVGlsZUlkIG9mIE9iamVjdC5rZXlzKHRpbGVzSnNvbikpIHtcclxuICAgICAgICBjb25zdCB0aWxlSnNvbiA9IHRpbGVzSnNvblthbmltYXRlZFRpbGVJZF07XHJcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uSnNvbiA9IHRpbGVKc29uLmFuaW1hdGlvbjtcclxuICAgICAgICBpZiAoYW5pbWF0aW9uSnNvbiAmJiBhbmltYXRpb25Kc29uLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgX2FkZEFuaW1hdGlvbnNGcm9tQW5pbWF0ZWRUaWxlLmJpbmQodGhpcykodGlsZXNldEpzb24sIGFuaW1hdGVkVGlsZUlkLCBhbmltYXRpb25Kc29uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9hZGRBbmltYXRpb25zRnJvbUFuaW1hdGVkVGlsZSh0aWxlc2V0SnNvbiwgYW5pbWF0ZWRUaWxlSWQsIGFuaW1hdGlvbkpzb24pIHtcclxuICAgIGNvbnN0IHRpbGVzID0gYW5pbWF0aW9uSnNvbi5tYXAoYW5pbWF0aW9uSnNvbiA9PiBhbmltYXRpb25Kc29uLnRpbGVpZCk7XHJcbiAgICBcclxuICAgIGNvbnN0IGZyYW1lSW50ZXJ2YWwgPSBhbmltYXRpb25Kc29uLmZpbmQoKCkgPT4gdHJ1ZSkuZHVyYXRpb247XHJcbiAgICBjb25zdCB0aWxlc2V0ID0gdGhpcy50aWxlbWFwLnRpbGVzZXRzLmZpbmQodCA9PiB0Lm5hbWUgPT09IHRpbGVzZXRKc29uLm5hbWUpO1xyXG4gICAgXHJcbiAgICBjb25zdCB0aWxlQW5pbWF0aW9uID0ge1xyXG4gICAgICAgIHRpbGVzLFxyXG4gICAgICAgIGZyYW1lSW50ZXJ2YWwsXHJcbiAgICAgICAgdGlsZXNldCxcclxuICAgICAgICB0aWxlTG9jYXRpb25zOiBfZ2V0VGlsZUxvY2F0aW9ucy5iaW5kKHRoaXMpKHRpbGVzZXQuZmlyc3RnaWQgKyBwYXJzZUludChhbmltYXRlZFRpbGVJZCkpLFxyXG4gICAgICAgIGN1cnJlbnRGcmFtZTogMCxcclxuICAgIH07ICAgICAgICBcclxuXHJcbiAgICB0aGlzLnRpbGVBbmltYXRpb25zLnB1c2godGlsZUFuaW1hdGlvbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9hbmltYXRlKCkge1xyXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSB0aGlzLnRpbWUubm93O1xyXG4gICAgbGV0IGRpcnR5ID0gZmFsc2U7XHJcbiAgICBmb3IgKGNvbnN0IHRpbGVBbmltYXRpb24gb2YgdGhpcy50aWxlQW5pbWF0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHRpbGVzID0gdGlsZUFuaW1hdGlvbi50aWxlcztcclxuICAgICAgICBjb25zdCBmcmFtZUludGVydmFsID0gdGlsZUFuaW1hdGlvbi5mcmFtZUludGVydmFsO1xyXG4gICAgICAgIGNvbnN0IHRpbGVzZXQgPSB0aWxlQW5pbWF0aW9uLnRpbGVzZXQ7XHJcbiAgICAgICAgY29uc3QgdGlsZUxvY2F0aW9ucyA9IHRpbGVBbmltYXRpb24udGlsZUxvY2F0aW9ucztcclxuICAgICAgICBjb25zdCBjdXJyZW50RnJhbWUgPSB0aWxlQW5pbWF0aW9uLmN1cnJlbnRGcmFtZTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBuZXdGcmFtZSA9IE1hdGguZmxvb3IoY3VycmVudFRpbWUgLyBmcmFtZUludGVydmFsKSAlIHRpbGVzLmxlbmd0aDtcclxuICAgICAgICBpZiAobmV3RnJhbWUgIT0gY3VycmVudEZyYW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0ZyYW1lSW5kZXggPSB0aWxlc2V0LmZpcnN0Z2lkICsgdGlsZXNbbmV3RnJhbWVdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRpbGVMb2NhdGlvbiBvZiB0aWxlTG9jYXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aWxlID0gdGhpcy50aWxlbWFwLmdldFRpbGUodGlsZUxvY2F0aW9uLngsIHRpbGVMb2NhdGlvbi55LCB0aWxlTG9jYXRpb24ubGF5ZXIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdGlsZS5pbmRleCA9IG5ld0ZyYW1lSW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGlsZUFuaW1hdGlvbi5jdXJyZW50RnJhbWUgPSBuZXdGcmFtZTtcclxuICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGlydHkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMudGlsZW1hcC5sYXllcnMpIHtcclxuICAgICAgICAgICAgbGF5ZXIuZGlydHkgPSB0cnVlOyAgICAgICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9nZXRUaWxlTG9jYXRpb25zKGFuaW1hdGVkVGlsZUlkKSB7XHJcbiAgICBjb25zdCB0aWxlTG9jYXRpb25zID0gW107XHJcbiAgICBmb3IgKGNvbnN0IGxheWVySnNvbiBvZiB0aGlzLnRpbGVtYXBKc29uLmxheWVycykge1xyXG4gICAgICAgIGlmIChsYXllckpzb24udHlwZSAhPT0gXCJ0aWxlbGF5ZXJcIikge1xyXG4gICAgICAgICAgICBjb250aW51ZTsgICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGxheWVySnNvbi5kYXRhO1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gbGF5ZXJKc29uLndpZHRoO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGxheWVySnNvbi5oZWlnaHQ7XHJcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhW3kgKiB3aWR0aCArIHhdID09PSBhbmltYXRlZFRpbGVJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbGVMb2NhdGlvbnMucHVzaCh7eCwgeSwgbGF5ZXI6IGxheWVySnNvbi5uYW1lfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGlsZUxvY2F0aW9ucztcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RpbGVtYXAtcGx1cy9BbmltYXRpb24uanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQTVCQTtBQUNBO0FBQ0E7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFLQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXFCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFnQkE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/*!*********************************!*\
  !*** ./tilemap-plus/Physics.js ***!
  \*********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Vector = __webpack_require__(/*! ./Vector */ 0);\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nvar _ConvexPolygon = __webpack_require__(/*! ./ConvexPolygon */ 6);\n\nvar _ConvexPolygon2 = _interopRequireDefault(_ConvexPolygon);\n\nvar _Range = __webpack_require__(/*! ./Range */ 1);\n\nvar _Range2 = _interopRequireDefault(_Range);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Physics = function () {\n    function Physics(tilemapJson) {\n        _classCallCheck(this, Physics);\n\n        this.tilemapJson = tilemapJson;\n        this.shapes = [];\n    }\n\n    _createClass(Physics, [{\n        key: \"enableObjectLayer\",\n        value: function enableObjectLayer(objectLayerName) {\n            var objectLayerJson = this.tilemapJson.layers.find(function (layer) {\n                return layer.type === \"objectgroup\" && layer.name === objectLayerName;\n            });\n            if (!objectLayerJson) {\n                throw new Error(\"No object layer found with name \\\"\" + objectLayerName + \"\\\"\");\n            }\n\n            this.shapes = [];\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = objectLayerJson.objects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var objectJson = _step.value;\n\n                    if (objectJson.polygon) {\n                        this.addPolygon(objectJson);\n                    } else if (objectJson.polyline) {\n                        // ignore poly line\n                    } else if (objectJson.ellipse) {\n                        // ignore ellipse\n                    } else if (objectJson.gid) {\n                        // ignore tile\n                    } else if (objectJson.text) {\n                        // ignore text\n                    } else {\n                        // rectangle\n                        this.addRectangle(objectJson);\n                    }\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"collideWith\",\n        value: function collideWith(sprite) {\n            var body = sprite.body;\n            var gravity = sprite.game.physics.arcade.gravity;\n            var gravityVector = new _Vector2.default(gravity.x, gravity.y);\n            var gravityNormal = gravityVector.normalized();\n            var velocity = new _Vector2.default(body.velocity.x, body.velocity.y);\n\n            if (!body.contactNormal) {\n                body.contactNormal = new _Vector2.default();\n            }\n            body.contactNormal.x = body.contactNormal.y = 0;\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this.shapes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var shape = _step2.value;\n\n                    var collision = shape.collideWidth(body);\n                    if (collision) {\n                        var penetration = collision.penetration;\n                        var normal = collision.normal;\n                        body.contactNormal = body.contactNormal.plus(normal);\n\n                        // resolve penetration\n                        body.x -= penetration.x;\n                        body.y -= penetration.y;\n\n                        // additional unit in direction of normal prevents sprite from\n                        // falling between vertical seams\n                        body.x += normal.x;\n                        body.y += normal.y;\n\n                        // if moving away, no resitution to compute\n                        var speedNormal = velocity.dot(normal);\n                        if (speedNormal >= 0) {\n                            continue;\n                        }\n\n                        // decompose old velocity into normal and tangent components\n                        var velocityNormal = normal.scale(speedNormal);\n                        var velocityTangent = velocity.minus(velocityNormal);\n\n                        // compute restitution on normal component\n                        var newVelocityNormal = void 0;\n                        var bounce = shape.properties && shape.properties.bounce;\n                        if (bounce && penetration.length() > 2) {\n                            newVelocityNormal = velocityNormal.scale(-bounce);\n                        } else {\n                            newVelocityNormal = new _Vector2.default();\n                        }\n\n                        // todo: compute friction on tangent component                \n                        var newVelocityTangent = velocityTangent;\n\n                        var newVelocity = newVelocityNormal.plus(newVelocityTangent);\n\n                        body.velocity.x = newVelocity.x;\n                        body.velocity.y = newVelocity.y;\n\n                        // prevent sprites sticking in adjacent shapes\n                        if (normal.dot(gravityVector) < 0) {\n                            body.x -= gravityNormal.x;\n                            body.y -= gravityNormal.y;\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            body.contactNormal = body.contactNormal.normalized();\n        }\n    }, {\n        key: \"addRectangle\",\n        value: function addRectangle(objectJson) {\n            // convert to convex polygon\n            var width = objectJson.width;\n            var height = objectJson.height;\n            var widthVector = new _Vector2.default(width, 0);\n            var heightVector = new _Vector2.default(0, height);\n            // handle box rotation\n            var angle = -objectJson.rotation * Math.PI / 180;\n            if (angle) {\n                widthVector = widthVector.rotated(angle);\n                heightVector = heightVector.rotated(angle);\n            }\n            var polygonJson = {\n                x: objectJson.x,\n                y: objectJson.y,\n                width: objectJson.width,\n                height: objectJson.height,\n                polygon: [{ x: 0, y: 0 }, widthVector, widthVector.plus(heightVector), heightVector],\n                properties: objectJson.properties\n            };\n            this.addPolygon(polygonJson);\n        }\n    }, {\n        key: \"addPolygon\",\n        value: function addPolygon(objectJson) {\n            var vertices = objectJson.polygon.map(function (point) {\n                return new _Vector2.default(objectJson.x + point.x, objectJson.y + point.y);\n            });\n            var convexPolygons = _ConvexPolygon2.default.generateConvexPolygons(vertices);\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = convexPolygons[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var convexPolygon = _step3.value;\n\n                    this.addConvexPolygon(convexPolygon, objectJson.properties);\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"addConvexPolygon\",\n        value: function addConvexPolygon(convexPolygon, properties) {\n            var left = Number.POSITIVE_INFINITY;\n            var top = Number.POSITIVE_INFINITY;\n            var right = Number.NEGATIVE_INFINITY;\n            var bottom = Number.NEGATIVE_INFINITY;\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n                for (var _iterator4 = convexPolygon.vertices[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                    var vertex = _step4.value;\n\n                    left = Math.min(left, vertex.x);\n                    top = Math.min(left, vertex.y);\n                    right = Math.max(left, vertex.x);\n                    bottom = Math.max(left, vertex.y);\n                }\n            } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                        _iterator4.return();\n                    }\n                } finally {\n                    if (_didIteratorError4) {\n                        throw _iteratorError4;\n                    }\n                }\n            }\n\n            var shape = {\n                type: \"polygon\",\n                left: left,\n                top: top,\n                right: right,\n                bottom: bottom,\n                polygon: convexPolygon,\n                properties: properties,\n                collideWidth: function collideWidth(body) {\n                    var bodyLeft = body.x;\n                    var bodyRight = body.x + body.width;\n                    var bodyTop = body.y;\n                    var bodyBottom = body.y + body.height;\n\n                    // sat axes - 2 ortho axis normals and object poly normals\n                    // first 2 normals prune search when sprite out of object bounding box\n                    var axes = [new _Vector2.default(1, 0), new _Vector2.default(0, 1)].concat(this.polygon.normals);\n\n                    var spritePolygon = _ConvexPolygon2.default.fromRectangle(bodyLeft, bodyTop, bodyRight, bodyBottom);\n\n                    var minPenetration = Number.POSITIVE_INFINITY;\n                    var minNormal = void 0;\n                    var _iteratorNormalCompletion5 = true;\n                    var _didIteratorError5 = false;\n                    var _iteratorError5 = undefined;\n\n                    try {\n                        for (var _iterator5 = axes[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                            var axis = _step5.value;\n\n                            var objectRange = this.polygon.projectOntoAxis(axis);\n                            var spriteRange = spritePolygon.projectOntoAxis(axis);\n                            var intersection = _Range2.default.intersection(objectRange, spriteRange);\n                            if (intersection.isEmpty()) {\n                                return null;\n                            }\n\n                            // intersection.length() not good enough for small objects\n                            // need to compute min of two potential penetrations from opposite sides\n                            var penetration = Math.min(Math.abs(objectRange.max - spriteRange.min), Math.abs(spriteRange.max - objectRange.min));\n                            if (minPenetration > penetration) {\n                                minPenetration = penetration;\n                                minNormal = axis;\n                            }\n                        }\n\n                        // ensure normal pointing towards sprite\n                    } catch (err) {\n                        _didIteratorError5 = true;\n                        _iteratorError5 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                                _iterator5.return();\n                            }\n                        } finally {\n                            if (_didIteratorError5) {\n                                throw _iteratorError5;\n                            }\n                        }\n                    }\n\n                    var spriteOffset = spritePolygon.centre.minus(this.polygon.centre);\n                    if (spriteOffset.dot(minNormal) < 0) {\n                        minNormal = minNormal.scale(-1);\n                    }\n\n                    var collision = {\n                        penetration: minNormal.scale(-minPenetration),\n                        normal: minNormal\n                    };\n\n                    return collision;\n                }\n            };\n            this.shapes.push(shape);\n        }\n    }]);\n\n    return Physics;\n}();\n\nexports.default = Physics;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdGlsZW1hcC1wbHVzL1BoeXNpY3MuanM/NDk5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVmVjdG9yIGZyb20gXCIuL1ZlY3RvclwiO1xyXG5pbXBvcnQgQ29udmV4UG9seWdvbiBmcm9tIFwiLi9Db252ZXhQb2x5Z29uXCI7XHJcbmltcG9ydCBSYW5nZSBmcm9tIFwiLi9SYW5nZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGh5c2ljcyB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0aWxlbWFwSnNvbikge1xyXG4gICAgICAgIHRoaXMudGlsZW1hcEpzb24gPSB0aWxlbWFwSnNvbjtcclxuICAgICAgICB0aGlzLnNoYXBlcyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIGVuYWJsZU9iamVjdExheWVyKG9iamVjdExheWVyTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IG9iamVjdExheWVySnNvbiA9IHRoaXMudGlsZW1hcEpzb24ubGF5ZXJzLmZpbmQobGF5ZXIgPT4gbGF5ZXIudHlwZSA9PT0gXCJvYmplY3Rncm91cFwiICYmIGxheWVyLm5hbWUgPT09IG9iamVjdExheWVyTmFtZSk7XHJcbiAgICAgICAgaWYgKCFvYmplY3RMYXllckpzb24pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBvYmplY3QgbGF5ZXIgZm91bmQgd2l0aCBuYW1lIFwiJHtvYmplY3RMYXllck5hbWV9XCJgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2hhcGVzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBvYmplY3RKc29uIG9mIG9iamVjdExheWVySnNvbi5vYmplY3RzKSB7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3RKc29uLnBvbHlnb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUG9seWdvbihvYmplY3RKc29uKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvYmplY3RKc29uLnBvbHlsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgcG9seSBsaW5lXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0SnNvbi5lbGxpcHNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZWxsaXBzZVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iamVjdEpzb24uZ2lkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdGlsZVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iamVjdEpzb24udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHRleHRcclxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFJlY3RhbmdsZShvYmplY3RKc29uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb2xsaWRlV2l0aChzcHJpdGUpIHtcclxuICAgICAgICBjb25zdCBib2R5ID0gc3ByaXRlLmJvZHk7XHJcbiAgICAgICAgY29uc3QgZ3Jhdml0eSA9IHNwcml0ZS5nYW1lLnBoeXNpY3MuYXJjYWRlLmdyYXZpdHk7XHJcbiAgICAgICAgY29uc3QgZ3Jhdml0eVZlY3RvciA9IG5ldyBWZWN0b3IoZ3Jhdml0eS54LCBncmF2aXR5LnkpO1xyXG4gICAgICAgIGNvbnN0IGdyYXZpdHlOb3JtYWwgPSBncmF2aXR5VmVjdG9yLm5vcm1hbGl6ZWQoKTtcclxuICAgICAgICBjb25zdCB2ZWxvY2l0eSA9IG5ldyBWZWN0b3IoYm9keS52ZWxvY2l0eS54LCBib2R5LnZlbG9jaXR5LnkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICghYm9keS5jb250YWN0Tm9ybWFsKSB7XHJcbiAgICAgICAgICAgIGJvZHkuY29udGFjdE5vcm1hbCA9IG5ldyBWZWN0b3IoKTsgICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgYm9keS5jb250YWN0Tm9ybWFsLnggPSBib2R5LmNvbnRhY3ROb3JtYWwueSA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBzaGFwZSBvZiB0aGlzLnNoYXBlcykge1xyXG4gICAgICAgICAgICBjb25zdCBjb2xsaXNpb24gPSBzaGFwZS5jb2xsaWRlV2lkdGgoYm9keSk7XHJcbiAgICAgICAgICAgIGlmIChjb2xsaXNpb24pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBlbmV0cmF0aW9uID0gY29sbGlzaW9uLnBlbmV0cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsID0gY29sbGlzaW9uLm5vcm1hbDtcclxuICAgICAgICAgICAgICAgIGJvZHkuY29udGFjdE5vcm1hbCA9IGJvZHkuY29udGFjdE5vcm1hbC5wbHVzKG5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIHJlc29sdmUgcGVuZXRyYXRpb25cclxuICAgICAgICAgICAgICAgIGJvZHkueCAtPSBwZW5ldHJhdGlvbi54O1xyXG4gICAgICAgICAgICAgICAgYm9keS55IC09IHBlbmV0cmF0aW9uLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYWRkaXRpb25hbCB1bml0IGluIGRpcmVjdGlvbiBvZiBub3JtYWwgcHJldmVudHMgc3ByaXRlIGZyb21cclxuICAgICAgICAgICAgICAgIC8vIGZhbGxpbmcgYmV0d2VlbiB2ZXJ0aWNhbCBzZWFtc1xyXG4gICAgICAgICAgICAgICAgYm9keS54ICs9IG5vcm1hbC54O1xyXG4gICAgICAgICAgICAgICAgYm9keS55ICs9IG5vcm1hbC55O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIG1vdmluZyBhd2F5LCBubyByZXNpdHV0aW9uIHRvIGNvbXB1dGVcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNwZWVkTm9ybWFsID0gdmVsb2NpdHkuZG90KG5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BlZWROb3JtYWwgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gZGVjb21wb3NlIG9sZCB2ZWxvY2l0eSBpbnRvIG5vcm1hbCBhbmQgdGFuZ2VudCBjb21wb25lbnRzXHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ZWxvY2l0eU5vcm1hbCA9IG5vcm1hbC5zY2FsZShzcGVlZE5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ZWxvY2l0eVRhbmdlbnQgPSB2ZWxvY2l0eS5taW51cyh2ZWxvY2l0eU5vcm1hbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY29tcHV0ZSByZXN0aXR1dGlvbiBvbiBub3JtYWwgY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3VmVsb2NpdHlOb3JtYWw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib3VuY2UgPSBzaGFwZS5wcm9wZXJ0aWVzICYmIHNoYXBlLnByb3BlcnRpZXMuYm91bmNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvdW5jZSAmJiBwZW5ldHJhdGlvbi5sZW5ndGgoKSA+IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWZWxvY2l0eU5vcm1hbCA9IHZlbG9jaXR5Tm9ybWFsLnNjYWxlKC1ib3VuY2UpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWZWxvY2l0eU5vcm1hbCA9IG5ldyBWZWN0b3IoKTsgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHRvZG86IGNvbXB1dGUgZnJpY3Rpb24gb24gdGFuZ2VudCBjb21wb25lbnQgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdWZWxvY2l0eVRhbmdlbnQgPSB2ZWxvY2l0eVRhbmdlbnQ7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZlbG9jaXR5ID0gbmV3VmVsb2NpdHlOb3JtYWwucGx1cyhuZXdWZWxvY2l0eVRhbmdlbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGJvZHkudmVsb2NpdHkueCA9IG5ld1ZlbG9jaXR5Lng7XHJcbiAgICAgICAgICAgICAgICBib2R5LnZlbG9jaXR5LnkgPSBuZXdWZWxvY2l0eS55O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgc3ByaXRlcyBzdGlja2luZyBpbiBhZGphY2VudCBzaGFwZXNcclxuICAgICAgICAgICAgICAgIGlmIChub3JtYWwuZG90KGdyYXZpdHlWZWN0b3IpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkueCAtPSBncmF2aXR5Tm9ybWFsLng7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keS55IC09IGdyYXZpdHlOb3JtYWwueTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBib2R5LmNvbnRhY3ROb3JtYWwgPSBib2R5LmNvbnRhY3ROb3JtYWwubm9ybWFsaXplZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZFJlY3RhbmdsZShvYmplY3RKc29uKSB7XHJcbiAgICAgICAgLy8gY29udmVydCB0byBjb252ZXggcG9seWdvblxyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gb2JqZWN0SnNvbi53aWR0aDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBvYmplY3RKc29uLmhlaWdodDtcclxuICAgICAgICBsZXQgd2lkdGhWZWN0b3IgPSBuZXcgVmVjdG9yKHdpZHRoLCAwKTtcclxuICAgICAgICBsZXQgaGVpZ2h0VmVjdG9yID0gbmV3IFZlY3RvcigwLCBoZWlnaHQpO1xyXG4gICAgICAgIC8vIGhhbmRsZSBib3ggcm90YXRpb25cclxuICAgICAgICBjb25zdCBhbmdsZSA9IC1vYmplY3RKc29uLnJvdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgICBpZiAoYW5nbGUpIHtcclxuICAgICAgICAgICAgd2lkdGhWZWN0b3IgPSB3aWR0aFZlY3Rvci5yb3RhdGVkKGFuZ2xlKTtcclxuICAgICAgICAgICAgaGVpZ2h0VmVjdG9yID0gaGVpZ2h0VmVjdG9yLnJvdGF0ZWQoYW5nbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwb2x5Z29uSnNvbiA9IHtcclxuICAgICAgICAgICAgeDogb2JqZWN0SnNvbi54LFxyXG4gICAgICAgICAgICB5OiBvYmplY3RKc29uLnksXHJcbiAgICAgICAgICAgIHdpZHRoOiBvYmplY3RKc29uLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IG9iamVjdEpzb24uaGVpZ2h0LFxyXG4gICAgICAgICAgICBwb2x5Z29uOiBbe3g6IDAsIHk6IDB9LCB3aWR0aFZlY3Rvciwgd2lkdGhWZWN0b3IucGx1cyhoZWlnaHRWZWN0b3IpLCBoZWlnaHRWZWN0b3JdLFxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBvYmplY3RKc29uLnByb3BlcnRpZXNcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYWRkUG9seWdvbihwb2x5Z29uSnNvbik7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkUG9seWdvbihvYmplY3RKc29uKSB7XHJcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBvYmplY3RKc29uLnBvbHlnb24ubWFwKFxyXG4gICAgICAgICAgICBwb2ludCA9PiBuZXcgVmVjdG9yKG9iamVjdEpzb24ueCArIHBvaW50LngsIG9iamVjdEpzb24ueSArIHBvaW50LnkpXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBjb252ZXhQb2x5Z29ucyA9IENvbnZleFBvbHlnb24uZ2VuZXJhdGVDb252ZXhQb2x5Z29ucyh2ZXJ0aWNlcyk7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb252ZXhQb2x5Z29uIG9mIGNvbnZleFBvbHlnb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ29udmV4UG9seWdvbihjb252ZXhQb2x5Z29uLCBvYmplY3RKc29uLnByb3BlcnRpZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhZGRDb252ZXhQb2x5Z29uKGNvbnZleFBvbHlnb24sIHByb3BlcnRpZXMpIHtcclxuICAgICAgICBsZXQgbGVmdCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgICBsZXQgdG9wID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgICAgIGxldCByaWdodCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcclxuICAgICAgICBsZXQgYm90dG9tID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xyXG4gICAgICAgIGZvciAoY29uc3QgdmVydGV4IG9mIGNvbnZleFBvbHlnb24udmVydGljZXMpIHtcclxuICAgICAgICAgICAgbGVmdCA9IE1hdGgubWluKGxlZnQsIHZlcnRleC54KTtcclxuICAgICAgICAgICAgdG9wID0gTWF0aC5taW4obGVmdCwgdmVydGV4LnkpO1xyXG4gICAgICAgICAgICByaWdodCA9IE1hdGgubWF4KGxlZnQsIHZlcnRleC54KTtcclxuICAgICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgobGVmdCwgdmVydGV4LnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBzaGFwZSA9IHsgICAgICAgICAgICBcclxuICAgICAgICAgICAgdHlwZTogXCJwb2x5Z29uXCIsXHJcbiAgICAgICAgICAgIGxlZnQsXHJcbiAgICAgICAgICAgIHRvcCxcclxuICAgICAgICAgICAgcmlnaHQsXHJcbiAgICAgICAgICAgIGJvdHRvbSxcclxuICAgICAgICAgICAgcG9seWdvbjogY29udmV4UG9seWdvbixcclxuICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllcyxcclxuICAgICAgICAgICAgY29sbGlkZVdpZHRoOiBmdW5jdGlvbihib2R5KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5TGVmdCA9IGJvZHkueDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlSaWdodCA9IGJvZHkueCArIGJvZHkud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5VG9wID0gYm9keS55O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm9keUJvdHRvbSA9IGJvZHkueSArIGJvZHkuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNhdCBheGVzIC0gMiBvcnRobyBheGlzIG5vcm1hbHMgYW5kIG9iamVjdCBwb2x5IG5vcm1hbHNcclxuICAgICAgICAgICAgICAgIC8vIGZpcnN0IDIgbm9ybWFscyBwcnVuZSBzZWFyY2ggd2hlbiBzcHJpdGUgb3V0IG9mIG9iamVjdCBib3VuZGluZyBib3hcclxuICAgICAgICAgICAgICAgIGNvbnN0IGF4ZXMgPSBbbmV3IFZlY3RvcigxLCAwKSwgbmV3IFZlY3RvcigwLCAxKV0uY29uY2F0KHRoaXMucG9seWdvbi5ub3JtYWxzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcHJpdGVQb2x5Z29uID0gQ29udmV4UG9seWdvbi5mcm9tUmVjdGFuZ2xlKGJvZHlMZWZ0LCBib2R5VG9wLCBib2R5UmlnaHQsIGJvZHlCb3R0b20pO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBtaW5QZW5ldHJhdGlvbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgICAgICAgICAgIGxldCBtaW5Ob3JtYWw7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGF4aXMgb2YgYXhlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdFJhbmdlID0gdGhpcy5wb2x5Z29uLnByb2plY3RPbnRvQXhpcyhheGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcHJpdGVSYW5nZSA9IHNwcml0ZVBvbHlnb24ucHJvamVjdE9udG9BeGlzKGF4aXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IFJhbmdlLmludGVyc2VjdGlvbihvYmplY3RSYW5nZSwgc3ByaXRlUmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJzZWN0aW9uLmxlbmd0aCgpIG5vdCBnb29kIGVub3VnaCBmb3Igc21hbGwgb2JqZWN0c1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gY29tcHV0ZSBtaW4gb2YgdHdvIHBvdGVudGlhbCBwZW5ldHJhdGlvbnMgZnJvbSBvcHBvc2l0ZSBzaWRlc1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwZW5ldHJhdGlvbiA9IE1hdGgubWluKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhvYmplY3RSYW5nZS5tYXggLSBzcHJpdGVSYW5nZS5taW4pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhzcHJpdGVSYW5nZS5tYXggLSBvYmplY3RSYW5nZS5taW4pKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWluUGVuZXRyYXRpb24gPiBwZW5ldHJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5QZW5ldHJhdGlvbiA9IHBlbmV0cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5Ob3JtYWwgPSBheGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIG5vcm1hbCBwb2ludGluZyB0b3dhcmRzIHNwcml0ZVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ByaXRlT2Zmc2V0ID0gc3ByaXRlUG9seWdvbi5jZW50cmUubWludXModGhpcy5wb2x5Z29uLmNlbnRyZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3ByaXRlT2Zmc2V0LmRvdChtaW5Ob3JtYWwpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbk5vcm1hbCA9IG1pbk5vcm1hbC5zY2FsZSgtMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGlzaW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHBlbmV0cmF0aW9uOiBtaW5Ob3JtYWwuc2NhbGUoLW1pblBlbmV0cmF0aW9uKSxcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWw6IG1pbk5vcm1hbFxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGlzaW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnNoYXBlcy5wdXNoKHNoYXBlKTtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdGlsZW1hcC1wbHVzL1BoeXNpY3MuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7OztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFPQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFyQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXNCQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFXQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTVEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUE0REE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFKQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBS0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQVBBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFLQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBY0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBckRBO0FBdURBO0FBQ0E7Ozs7OztBQW5NQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/*!***************************************!*\
  !*** ./tilemap-plus/ConvexPolygon.js ***!
  \***************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _polyDecomp = __webpack_require__(/*! poly-decomp */ 7);\n\nvar _polyDecomp2 = _interopRequireDefault(_polyDecomp);\n\nvar _Vector = __webpack_require__(/*! ./Vector */ 0);\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nvar _AABB = __webpack_require__(/*! ./AABB */ 8);\n\nvar _AABB2 = _interopRequireDefault(_AABB);\n\nvar _Range = __webpack_require__(/*! ./Range */ 1);\n\nvar _Range2 = _interopRequireDefault(_Range);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar average = function average(array) {\n    return array.reduce(function (accumulator, value) {\n        return accumulator + value;\n    }, 0) / array.length;\n};\n\nvar validateBounds = function validateBounds(left, top, right, bottom) {\n    if (left > right) {\n        throw new Error(\"Right must be greater than Left\");\n    }\n    if (top > bottom) {\n        throw new Error(\"Bottom must be greater than Top\");\n    }\n};\n\nvar ConvexPolygon = function () {\n    function ConvexPolygon(vertices) {\n        _classCallCheck(this, ConvexPolygon);\n\n        this.vertices = vertices;\n        this.recompute();\n    }\n\n    _createClass(ConvexPolygon, [{\n        key: \"recompute\",\n        value: function recompute() {\n            var vertices = this.vertices;\n            this.aabb = _AABB2.default.fromPoints(vertices);\n            this.edges = [];\n            this.normals = [];\n            this.count = vertices.length;\n            this.centre = new _Vector2.default(average(vertices.map(function (v) {\n                return v.x;\n            })), average(vertices.map(function (v) {\n                return v.y;\n            })));\n\n            if (this.count > 1) {\n                for (var i = 0; i < this.count; i++) {\n                    var j = (i + 1) % this.count;\n                    var edge = vertices[j].minus(vertices[i]);\n                    this.edges.push(edge);\n                    // generate outward normals\n                    var normal = edge.normalized().perpendicular();\n                    var radius = vertices[i].minus(this.centre);\n                    if (radius.dot(normal) < 0) {\n                        normal = normal.scale(-1);\n                    }\n                    this.normals.push(normal);\n                }\n            }\n        }\n    }, {\n        key: \"isValid\",\n        value: function isValid() {\n            if (this.count < 4) {\n                return true;\n            }\n            var prevPerpDot = 0;\n            for (var i = 0; i < this.count; i++) {\n                var j = (i + 1) % this.count;\n                var perpDot = this.edges[i].perpDot(this.edges[j]);\n                if (perpDot * prevPerpDot < 0) {\n                    return false;\n                }\n                prevPerpDot = perpDot;\n            }\n            return true;\n        }\n    }, {\n        key: \"projectOntoAxis\",\n        value: function projectOntoAxis(axis) {\n            var range = new _Range2.default();\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.vertices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var vertex = _step.value;\n\n                    var projection = vertex.dot(axis);\n                    range.extendTo(projection);\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            return range;\n        }\n    }, {\n        key: \"rotated\",\n        value: function rotated(angle) {\n            var rotatedVertices = [];\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this.vertices[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var vertex = _step2.value;\n\n                    var vertexOffset = new _Vector2.default(vertex.x, vertex.y).minus(this.centre);\n                    var rotatedOffset = vertexOffset.rotated(angle);\n                    var rotatedVertex = this.centre.plus(rotatedOffset);\n                    rotatedVertices.push(rotatedVertex);\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            return new ConvexPolygon(rotatedVertices);\n        }\n    }], [{\n        key: \"fromRectangle\",\n        value: function fromRectangle(left, top, right, bottom) {\n            validateBounds(left, top, right, bottom);\n\n            var vertices = [new _Vector2.default(left, top), new _Vector2.default(right, top), new _Vector2.default(right, bottom), new _Vector2.default(left, bottom)];\n            return new ConvexPolygon(vertices);\n        }\n    }, {\n        key: \"fromCapsule\",\n        value: function fromCapsule(left, top, right, bottom, capSegments) {\n            if (capSegments < 3) {\n                throw new Error(\"Specify at least 3 cap segments\");\n            }\n            validateBounds(left, top, right, bottom);\n            var width = right - left;\n            var height = bottom - top;\n            if (height < width) {\n                throw new Error(\"Capsule height must be larger than width\");\n            }\n            var capRadius = width * 0.5;\n            var capAngles = [].concat(_toConsumableArray(Array(capSegments).keys())).map(function (index) {\n                return -index * Math.PI / capSegments;\n            });\n\n            var centreX = (left + right) * 0.5;\n            var capVertices = capAngles.map(function (angle) {\n                return new _Vector2.default(Math.cos(angle), Math.sin(angle)).scale(capRadius);\n            });\n            var topCapFocus = new _Vector2.default(centreX, top + capRadius);\n            var vertices = capVertices.map(function (capVertex) {\n                return topCapFocus.plus(capVertex);\n            });\n            vertices.push(new _Vector2.default(left, topCapFocus.y));\n            var bottomCapFocus = new _Vector2.default(centreX, bottom - capRadius);\n            vertices = vertices.concat(capVertices.map(function (capVertex) {\n                return bottomCapFocus.minus(capVertex);\n            }));\n            vertices.push(new _Vector2.default(right, bottomCapFocus.y));\n\n            return new ConvexPolygon(vertices);\n        }\n    }, {\n        key: \"generateConvexPolygons\",\n        value: function generateConvexPolygons(vertices) {\n            var pdVertices = vertices.map(function (v) {\n                return [v.x, v.y];\n            });\n            var pdConvexPolygons = _polyDecomp2.default.decomp(pdVertices);\n            var convexPolygons = pdConvexPolygons.map(function (pdConvexPolygon) {\n                return new ConvexPolygon(pdConvexPolygon.map(function (pdVertex) {\n                    return new _Vector2.default(pdVertex[0], pdVertex[1]);\n                }));\n            });\n            return convexPolygons;\n        }\n    }]);\n\n    return ConvexPolygon;\n}();\n\nexports.default = ConvexPolygon;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdGlsZW1hcC1wbHVzL0NvbnZleFBvbHlnb24uanM/NWFkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUG9seURlY29tcCBmcm9tIFwicG9seS1kZWNvbXBcIjtcclxuaW1wb3J0IFZlY3RvciBmcm9tIFwiLi9WZWN0b3JcIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4vQUFCQlwiO1xyXG5pbXBvcnQgUmFuZ2UgZnJvbSBcIi4vUmFuZ2VcIjtcclxuXHJcbmNvbnN0IGF2ZXJhZ2UgPSAoYXJyYXkpID0+IGFycmF5LnJlZHVjZSggKCBhY2N1bXVsYXRvciwgdmFsdWUgKSA9PiBhY2N1bXVsYXRvciArIHZhbHVlLCAwICkgLyBhcnJheS5sZW5ndGg7XHJcblxyXG5jb25zdCB2YWxpZGF0ZUJvdW5kcyA9IChsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pID0+IHtcclxuICAgIGlmIChsZWZ0ID4gcmlnaHQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSaWdodCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBMZWZ0XCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRvcCA+IGJvdHRvbSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJvdHRvbSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBUb3BcIik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb252ZXhQb2x5Z29uIHtcclxuICAgIGNvbnN0cnVjdG9yKHZlcnRpY2VzKSB7XHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xyXG4gICAgICAgIHRoaXMucmVjb21wdXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVjb21wdXRlKCkge1xyXG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgICAgICB0aGlzLmFhYmIgPSBBQUJCLmZyb21Qb2ludHModmVydGljZXMpO1xyXG4gICAgICAgIHRoaXMuZWRnZXMgPSBbXTtcclxuICAgICAgICB0aGlzLm5vcm1hbHMgPSBbXTtcclxuICAgICAgICB0aGlzLmNvdW50ID0gdmVydGljZXMubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuY2VudHJlID0gbmV3IFZlY3RvcihcclxuICAgICAgICAgICAgYXZlcmFnZSh2ZXJ0aWNlcy5tYXAodiA9PiB2LngpKSxcclxuICAgICAgICAgICAgYXZlcmFnZSh2ZXJ0aWNlcy5tYXAodiA9PiB2LnkpKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPiAxKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaiA9IChpICsgMSkgJSB0aGlzLmNvdW50O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWRnZSA9IHZlcnRpY2VzW2pdLm1pbnVzKHZlcnRpY2VzW2ldKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWRnZXMucHVzaChlZGdlKTtcclxuICAgICAgICAgICAgICAgIC8vIGdlbmVyYXRlIG91dHdhcmQgbm9ybWFsc1xyXG4gICAgICAgICAgICAgICAgbGV0IG5vcm1hbCA9IGVkZ2Uubm9ybWFsaXplZCgpLnBlcnBlbmRpY3VsYXIoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IHZlcnRpY2VzW2ldLm1pbnVzKHRoaXMuY2VudHJlKTtcclxuICAgICAgICAgICAgICAgIGlmIChyYWRpdXMuZG90KG5vcm1hbCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsID0gbm9ybWFsLnNjYWxlKC0xKTtcclxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vcm1hbHMucHVzaChub3JtYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlzVmFsaWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPCA0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcHJldlBlcnBEb3QgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBqID0gKGkgKyAxKSAlIHRoaXMuY291bnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHBlcnBEb3QgPSB0aGlzLmVkZ2VzW2ldLnBlcnBEb3QodGhpcy5lZGdlc1tqXSk7XHJcbiAgICAgICAgICAgIGlmIChwZXJwRG90ICogcHJldlBlcnBEb3QgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldlBlcnBEb3QgPSBwZXJwRG90O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcm9qZWN0T250b0F4aXMoYXhpcykge1xyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gbmV3IFJhbmdlKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCB2ZXJ0ZXggb2YgdGhpcy52ZXJ0aWNlcykge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0aW9uID0gdmVydGV4LmRvdChheGlzKTtcclxuICAgICAgICAgICAgcmFuZ2UuZXh0ZW5kVG8ocHJvamVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByYW5nZTtcclxuICAgIH1cclxuXHJcbiAgICByb3RhdGVkKGFuZ2xlKSB7XHJcbiAgICAgICAgY29uc3Qgcm90YXRlZFZlcnRpY2VzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCB2ZXJ0ZXggb2YgdGhpcy52ZXJ0aWNlcykge1xyXG4gICAgICAgICAgICBjb25zdCB2ZXJ0ZXhPZmZzZXQgPSBuZXcgVmVjdG9yKHZlcnRleC54LCB2ZXJ0ZXgueSkubWludXModGhpcy5jZW50cmUpO1xyXG4gICAgICAgICAgICBjb25zdCByb3RhdGVkT2Zmc2V0ID0gdmVydGV4T2Zmc2V0LnJvdGF0ZWQoYW5nbGUpO1xyXG4gICAgICAgICAgICBjb25zdCByb3RhdGVkVmVydGV4ID0gdGhpcy5jZW50cmUucGx1cyhyb3RhdGVkT2Zmc2V0KTtcclxuICAgICAgICAgICAgcm90YXRlZFZlcnRpY2VzLnB1c2gocm90YXRlZFZlcnRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQ29udmV4UG9seWdvbihyb3RhdGVkVmVydGljZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBmcm9tUmVjdGFuZ2xlKGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xyXG4gICAgICAgIHZhbGlkYXRlQm91bmRzKGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gW1xyXG4gICAgICAgICAgICBuZXcgVmVjdG9yKGxlZnQsIHRvcCksXHJcbiAgICAgICAgICAgIG5ldyBWZWN0b3IocmlnaHQsIHRvcCksXHJcbiAgICAgICAgICAgIG5ldyBWZWN0b3IocmlnaHQsIGJvdHRvbSksXHJcbiAgICAgICAgICAgIG5ldyBWZWN0b3IobGVmdCwgYm90dG9tKVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb252ZXhQb2x5Z29uKHZlcnRpY2VzKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZnJvbUNhcHN1bGUobGVmdCwgdG9wLCByaWdodCwgYm90dG9tLCBjYXBTZWdtZW50cykge1xyXG4gICAgICAgIGlmIChjYXBTZWdtZW50cyA8IDMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3BlY2lmeSBhdCBsZWFzdCAzIGNhcCBzZWdtZW50c1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsaWRhdGVCb3VuZHMobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKTtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7ICAgICAgICBcclxuICAgICAgICBpZiAoaGVpZ2h0IDwgd2lkdGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fwc3VsZSBoZWlnaHQgbXVzdCBiZSBsYXJnZXIgdGhhbiB3aWR0aFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2FwUmFkaXVzID0gd2lkdGggKiAwLjU7XHJcbiAgICAgICAgY29uc3QgY2FwQW5nbGVzID0gWy4uLkFycmF5KGNhcFNlZ21lbnRzKS5rZXlzKCldLm1hcChpbmRleCA9PiAtaW5kZXggKiBNYXRoLlBJIC8gY2FwU2VnbWVudHMpO1xyXG5cclxuICAgICAgICBjb25zdCBjZW50cmVYID0gKGxlZnQgKyByaWdodCkgKiAwLjU7XHJcbiAgICAgICAgY29uc3QgY2FwVmVydGljZXMgPSBjYXBBbmdsZXMubWFwKGFuZ2xlID0+IG5ldyBWZWN0b3IoTWF0aC5jb3MoYW5nbGUpLCBNYXRoLnNpbihhbmdsZSkpLnNjYWxlKGNhcFJhZGl1cykpO1xyXG4gICAgICAgIGNvbnN0IHRvcENhcEZvY3VzID0gbmV3IFZlY3RvcihjZW50cmVYLCB0b3AgKyBjYXBSYWRpdXMpO1xyXG4gICAgICAgIGxldCB2ZXJ0aWNlcyA9IGNhcFZlcnRpY2VzLm1hcChjYXBWZXJ0ZXggPT4gdG9wQ2FwRm9jdXMucGx1cyhjYXBWZXJ0ZXgpKTtcclxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKG5ldyBWZWN0b3IobGVmdCwgdG9wQ2FwRm9jdXMueSkpO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbUNhcEZvY3VzID0gbmV3IFZlY3RvcihjZW50cmVYLCBib3R0b20gLSBjYXBSYWRpdXMpO1xyXG4gICAgICAgIHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KGNhcFZlcnRpY2VzLm1hcChjYXBWZXJ0ZXggPT4gYm90dG9tQ2FwRm9jdXMubWludXMoY2FwVmVydGV4KSkpO1xyXG4gICAgICAgIHZlcnRpY2VzLnB1c2gobmV3IFZlY3RvcihyaWdodCwgYm90dG9tQ2FwRm9jdXMueSkpO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IENvbnZleFBvbHlnb24odmVydGljZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZW5lcmF0ZUNvbnZleFBvbHlnb25zKHZlcnRpY2VzKSB7XHJcbiAgICAgICAgY29uc3QgcGRWZXJ0aWNlcyA9IHZlcnRpY2VzLm1hcCh2ID0+IFt2LngsIHYueV0pO1xyXG4gICAgICAgIGNvbnN0IHBkQ29udmV4UG9seWdvbnMgPSBQb2x5RGVjb21wLmRlY29tcChwZFZlcnRpY2VzKTtcclxuICAgICAgICBjb25zdCBjb252ZXhQb2x5Z29ucyA9IHBkQ29udmV4UG9seWdvbnMubWFwKHBkQ29udmV4UG9seWdvbiA9PlxyXG4gICAgICAgICAgICBuZXcgQ29udmV4UG9seWdvbihwZENvbnZleFBvbHlnb24ubWFwKHBkVmVydGV4ID0+XHJcbiAgICAgICAgICAgICAgICBuZXcgVmVjdG9yKHBkVmVydGV4WzBdLCBwZFZlcnRleFsxXSkpXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBjb252ZXhQb2x5Z29ucztcclxuICAgIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RpbGVtYXAtcGx1cy9Db252ZXhQb2x5Z29uLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7Ozs7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7OztBQUVBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFLQTtBQUNBOzs7Ozs7QUFuSEEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/*!************************************************!*\
  !*** ../node_modules/poly-decomp/src/index.js ***!
  \************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = {\n    decomp: polygonDecomp,\n    quickDecomp: polygonQuickDecomp,\n    isSimple: polygonIsSimple,\n    removeCollinearPoints: polygonRemoveCollinearPoints,\n    makeCCW: polygonMakeCCW\n};\n\n/**\n * Compute the intersection between two lines.\n * @static\n * @method lineInt\n * @param  {Array}  l1          Line vector 1\n * @param  {Array}  l2          Line vector 2\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\n * @return {Array}              The intersection point.\n */\nfunction lineInt(l1,l2,precision){\n    precision = precision || 0;\n    var i = [0,0]; // point\n    var a1, b1, c1, a2, b2, c2, det; // scalars\n    a1 = l1[1][1] - l1[0][1];\n    b1 = l1[0][0] - l1[1][0];\n    c1 = a1 * l1[0][0] + b1 * l1[0][1];\n    a2 = l2[1][1] - l2[0][1];\n    b2 = l2[0][0] - l2[1][0];\n    c2 = a2 * l2[0][0] + b2 * l2[0][1];\n    det = a1 * b2 - a2*b1;\n    if (!scalar_eq(det, 0, precision)) { // lines are not parallel\n        i[0] = (b2 * c1 - b1 * c2) / det;\n        i[1] = (a1 * c2 - a2 * c1) / det;\n    }\n    return i;\n}\n\n/**\n * Checks if two line segments intersects.\n * @method segmentsIntersect\n * @param {Array} p1 The start vertex of the first line segment.\n * @param {Array} p2 The end vertex of the first line segment.\n * @param {Array} q1 The start vertex of the second line segment.\n * @param {Array} q2 The end vertex of the second line segment.\n * @return {Boolean} True if the two line segments intersect\n */\nfunction lineSegmentsIntersect(p1, p2, q1, q2){\n\tvar dx = p2[0] - p1[0];\n\tvar dy = p2[1] - p1[1];\n\tvar da = q2[0] - q1[0];\n\tvar db = q2[1] - q1[1];\n\n\t// segments are parallel\n\tif((da*dy - db*dx) === 0){\n\t\treturn false;\n\t}\n\n\tvar s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\n\tvar t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\n\n\treturn (s>=0 && s<=1 && t>=0 && t<=1);\n}\n\n/**\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\n * @static\n * @method area\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @return {Number}\n */\nfunction triangleArea(a,b,c){\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));\n}\n\nfunction isLeft(a,b,c){\n    return triangleArea(a,b,c) > 0;\n}\n\nfunction isLeftOn(a,b,c) {\n    return triangleArea(a, b, c) >= 0;\n}\n\nfunction isRight(a,b,c) {\n    return triangleArea(a, b, c) < 0;\n}\n\nfunction isRightOn(a,b,c) {\n    return triangleArea(a, b, c) <= 0;\n}\n\nvar tmpPoint1 = [],\n    tmpPoint2 = [];\n\n/**\n * Check if three points are collinear\n * @method collinear\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\n * @return {Boolean}\n */\nfunction collinear(a,b,c,thresholdAngle) {\n    if(!thresholdAngle){\n        return triangleArea(a, b, c) === 0;\n    } else {\n        var ab = tmpPoint1,\n            bc = tmpPoint2;\n\n        ab[0] = b[0]-a[0];\n        ab[1] = b[1]-a[1];\n        bc[0] = c[0]-b[0];\n        bc[1] = c[1]-b[1];\n\n        var dot = ab[0]*bc[0] + ab[1]*bc[1],\n            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),\n            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),\n            angle = Math.acos(dot/(magA*magB));\n        return angle < thresholdAngle;\n    }\n}\n\nfunction sqdist(a,b){\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    return dx * dx + dy * dy;\n}\n\n/**\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\n * @method at\n * @param  {Number} i\n * @return {Array}\n */\nfunction polygonAt(polygon, i){\n    var s = polygon.length;\n    return polygon[i < 0 ? i % s + s : i % s];\n}\n\n/**\n * Clear the polygon data\n * @method clear\n * @return {Array}\n */\nfunction polygonClear(polygon){\n    polygon.length = 0;\n}\n\n/**\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\n * @method append\n * @param {Polygon} poly The polygon to get points from.\n * @param {Number}  from The vertex index in \"poly\".\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\n * @return {Array}\n */\nfunction polygonAppend(polygon, poly, from, to){\n    for(var i=from; i<to; i++){\n        polygon.push(poly[i]);\n    }\n}\n\n/**\n * Make sure that the polygon vertices are ordered counter-clockwise.\n * @method makeCCW\n */\nfunction polygonMakeCCW(polygon){\n    var br = 0,\n        v = polygon;\n\n    // find bottom right point\n    for (var i = 1; i < polygon.length; ++i) {\n        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {\n            br = i;\n        }\n    }\n\n    // reverse poly if clockwise\n    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\n        polygonReverse(polygon);\n    }\n}\n\n/**\n * Reverse the vertices in the polygon\n * @method reverse\n */\nfunction polygonReverse(polygon){\n    var tmp = [];\n    var N = polygon.length;\n    for(var i=0; i!==N; i++){\n        tmp.push(polygon.pop());\n    }\n    for(var i=0; i!==N; i++){\n\t\tpolygon[i] = tmp[i];\n    }\n}\n\n/**\n * Check if a point in the polygon is a reflex point\n * @method isReflex\n * @param  {Number}  i\n * @return {Boolean}\n */\nfunction polygonIsReflex(polygon, i){\n    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\n}\n\nvar tmpLine1=[],\n    tmpLine2=[];\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee(polygon, a,b) {\n    var p, dist, l1=tmpLine1, l2=tmpLine2;\n\n    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\n        return false;\n    }\n    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\n    for (var i = 0; i !== polygon.length; ++i) { // for each edge\n        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges\n            continue;\n        }\n        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge\n            l1[0] = polygonAt(polygon, a);\n            l1[1] = polygonAt(polygon, b);\n            l2[0] = polygonAt(polygon, i);\n            l2[1] = polygonAt(polygon, i + 1);\n            p = lineInt(l1,l2);\n            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n/**\n * Copy the polygon from vertex i to vertex j.\n * @method copy\n * @param  {Number} i\n * @param  {Number} j\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\n * @return {Polygon}                The resulting copy.\n */\nfunction polygonCopy(polygon, i,j,targetPoly){\n    var p = targetPoly || [];\n    polygonClear(p);\n    if (i < j) {\n        // Insert all vertices from i to j\n        for(var k=i; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n    } else {\n\n        // Insert vertices 0 to j\n        for(var k=0; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n        // Insert vertices i to end\n        for(var k=i; k<polygon.length; k++){\n            p.push(polygon[k]);\n        }\n    }\n\n    return p;\n}\n\n/**\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\n * @method getCutEdges\n * @return {Array}\n */\nfunction polygonGetCutEdges(polygon) {\n    var min=[], tmp1=[], tmp2=[], tmpPoly = [];\n    var nDiags = Number.MAX_VALUE;\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(polygon, i)) {\n            for (var j = 0; j < polygon.length; ++j) {\n                if (polygonCanSee(polygon, i, j)) {\n                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\n                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\n\n                    for(var k=0; k<tmp2.length; k++){\n                        tmp1.push(tmp2[k]);\n                    }\n\n                    if (tmp1.length < nDiags) {\n                        min = tmp1;\n                        nDiags = tmp1.length;\n                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);\n                    }\n                }\n            }\n        }\n    }\n\n    return min;\n}\n\n/**\n * Decomposes the polygon into one or more convex sub-Polygons.\n * @method decomp\n * @return {Array} An array or Polygon objects.\n */\nfunction polygonDecomp(polygon){\n    var edges = polygonGetCutEdges(polygon);\n    if(edges.length > 0){\n        return polygonSlice(polygon, edges);\n    } else {\n        return [polygon];\n    }\n}\n\n/**\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\n * @method slice\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\n * @return {Array}\n */\nfunction polygonSlice(polygon, cutEdges){\n    if(cutEdges.length === 0){\n\t\treturn [polygon];\n    }\n    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length===2 && cutEdges[0][0] instanceof Array){\n\n        var polys = [polygon];\n\n        for(var i=0; i<cutEdges.length; i++){\n            var cutEdge = cutEdges[i];\n            // Cut all polys\n            for(var j=0; j<polys.length; j++){\n                var poly = polys[j];\n                var result = polygonSlice(poly, cutEdge);\n                if(result){\n                    // Found poly! Cut and quit\n                    polys.splice(j,1);\n                    polys.push(result[0],result[1]);\n                    break;\n                }\n            }\n        }\n\n        return polys;\n    } else {\n\n        // Was given one edge\n        var cutEdge = cutEdges;\n        var i = polygon.indexOf(cutEdge[0]);\n        var j = polygon.indexOf(cutEdge[1]);\n\n        if(i !== -1 && j !== -1){\n            return [polygonCopy(polygon, i,j),\n                    polygonCopy(polygon, j,i)];\n        } else {\n            return false;\n        }\n    }\n}\n\n/**\n * Checks that the line segments of this polygon do not intersect each other.\n * @method isSimple\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\n * @return {Boolean}\n * @todo Should it check all segments with all others?\n */\nfunction polygonIsSimple(polygon){\n    var path = polygon, i;\n    // Check\n    for(i=0; i<path.length-1; i++){\n        for(var j=0; j<i-1; j++){\n            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){\n                return false;\n            }\n        }\n    }\n\n    // Check the segment between the last and the first point to all others\n    for(i=1; i<path.length-2; i++){\n        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction getIntersectionPoint(p1, p2, q1, q2, delta){\n\tdelta = delta || 0;\n\tvar a1 = p2[1] - p1[1];\n\tvar b1 = p1[0] - p2[0];\n\tvar c1 = (a1 * p1[0]) + (b1 * p1[1]);\n\tvar a2 = q2[1] - q1[1];\n\tvar b2 = q1[0] - q2[0];\n\tvar c2 = (a2 * q1[0]) + (b2 * q1[1]);\n\tvar det = (a1 * b2) - (a2 * b1);\n\n\tif(!scalar_eq(det,0,delta)){\n\t\treturn [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det];\n\t} else {\n\t\treturn [0,0];\n    }\n}\n\n/**\n * Quickly decompose the Polygon into convex sub-polygons.\n * @method quickDecomp\n * @param  {Array} result\n * @param  {Array} [reflexVertices]\n * @param  {Array} [steinerPoints]\n * @param  {Number} [delta]\n * @param  {Number} [maxlevel]\n * @param  {Number} [level]\n * @return {Array}\n */\nfunction polygonQuickDecomp(polygon, result,reflexVertices,steinerPoints,delta,maxlevel,level){\n    maxlevel = maxlevel || 100;\n    level = level || 0;\n    delta = delta || 25;\n    result = typeof(result)!==\"undefined\" ? result : [];\n    reflexVertices = reflexVertices || [];\n    steinerPoints = steinerPoints || [];\n\n    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points\n    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars\n    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers\n    var lowerPoly=[], upperPoly=[]; // polygons\n    var poly = polygon,\n        v = polygon;\n\n    if(v.length < 3){\n\t\treturn result;\n    }\n\n    level++;\n    if(level > maxlevel){\n        console.warn(\"quickDecomp: max level (\"+maxlevel+\") reached.\");\n        return result;\n    }\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(poly, i)) {\n            reflexVertices.push(poly[i]);\n            upperDist = lowerDist = Number.MAX_VALUE;\n\n\n            for (var j = 0; j < polygon.length; ++j) {\n                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge\n                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\n                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly\n                        d = sqdist(poly[i], p);\n                        if (d < lowerDist) { // keep only the closest intersection\n                            lowerDist = d;\n                            lowerInt = p;\n                            lowerIndex = j;\n                        }\n                    }\n                }\n                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\n                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\n                        d = sqdist(poly[i], p);\n                        if (d < upperDist) {\n                            upperDist = d;\n                            upperInt = p;\n                            upperIndex = j;\n                        }\n                    }\n                }\n            }\n\n            // if there are no vertices to connect to, choose a point in the middle\n            if (lowerIndex === (upperIndex + 1) % polygon.length) {\n                //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\n                p[0] = (lowerInt[0] + upperInt[0]) / 2;\n                p[1] = (lowerInt[1] + upperInt[1]) / 2;\n                steinerPoints.push(p);\n\n                if (i < upperIndex) {\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly, i, upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    if (lowerIndex !== 0){\n                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\n                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);\n                    }\n                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\n                        polygonAppend(lowerPoly, poly,i,poly.length);\n                    }\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly,0,upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,lowerIndex,i+1);\n                }\n            } else {\n                // connect to the closest point within the triangle\n                //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\n\n                if (lowerIndex > upperIndex) {\n                    upperIndex += polygon.length;\n                }\n                closestDist = Number.MAX_VALUE;\n\n                if(upperIndex < lowerIndex){\n                    return result;\n                }\n\n                for (var j = lowerIndex; j <= upperIndex; ++j) {\n                    if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\n                        if (d < closestDist) {\n                            closestDist = d;\n                            closestIndex = j % polygon.length;\n                        }\n                    }\n                }\n\n                if (i < closestIndex) {\n                    polygonAppend(lowerPoly, poly,i,closestIndex+1);\n                    if (closestIndex !== 0){\n                        polygonAppend(upperPoly, poly,closestIndex,v.length);\n                    }\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        polygonAppend(lowerPoly, poly,i,v.length);\n                    }\n                    polygonAppend(lowerPoly, poly,0,closestIndex+1);\n                    polygonAppend(upperPoly, poly,closestIndex,i+1);\n                }\n            }\n\n            // solve smallest poly first\n            if (lowerPoly.length < upperPoly.length) {\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            } else {\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            }\n\n            return result;\n        }\n    }\n    result.push(polygon);\n\n    return result;\n}\n\n/**\n * Remove collinear points in the polygon.\n * @method removeCollinearPoints\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\n * @return {Number}           The number of points removed\n */\nfunction polygonRemoveCollinearPoints(polygon, precision){\n    var num = 0;\n    for(var i=polygon.length-1; polygon.length>3 && i>=0; --i){\n        if(collinear(polygonAt(polygon, i-1),polygonAt(polygon, i),polygonAt(polygon, i+1),precision)){\n            // Remove the middle point\n            polygon.splice(i%polygon.length,1);\n            num++;\n        }\n    }\n    return num;\n}\n\n/**\n * Check if two scalars are equal\n * @static\n * @method eq\n * @param  {Number} a\n * @param  {Number} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction scalar_eq(a,b,precision){\n    precision = precision || 0;\n    return Math.abs(a-b) < precision;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcG9seS1kZWNvbXAvc3JjL2luZGV4LmpzP2YzNmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGVjb21wOiBwb2x5Z29uRGVjb21wLFxuICAgIHF1aWNrRGVjb21wOiBwb2x5Z29uUXVpY2tEZWNvbXAsXG4gICAgaXNTaW1wbGU6IHBvbHlnb25Jc1NpbXBsZSxcbiAgICByZW1vdmVDb2xsaW5lYXJQb2ludHM6IHBvbHlnb25SZW1vdmVDb2xsaW5lYXJQb2ludHMsXG4gICAgbWFrZUNDVzogcG9seWdvbk1ha2VDQ1dcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdHdvIGxpbmVzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBsaW5lSW50XG4gKiBAcGFyYW0gIHtBcnJheX0gIGwxICAgICAgICAgIExpbmUgdmVjdG9yIDFcbiAqIEBwYXJhbSAge0FycmF5fSAgbDIgICAgICAgICAgTGluZSB2ZWN0b3IgMlxuICogQHBhcmFtICB7TnVtYmVyfSBwcmVjaXNpb24gICBQcmVjaXNpb24gdG8gdXNlIHdoZW4gY2hlY2tpbmcgaWYgdGhlIGxpbmVzIGFyZSBwYXJhbGxlbFxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBUaGUgaW50ZXJzZWN0aW9uIHBvaW50LlxuICovXG5mdW5jdGlvbiBsaW5lSW50KGwxLGwyLHByZWNpc2lvbil7XG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDA7XG4gICAgdmFyIGkgPSBbMCwwXTsgLy8gcG9pbnRcbiAgICB2YXIgYTEsIGIxLCBjMSwgYTIsIGIyLCBjMiwgZGV0OyAvLyBzY2FsYXJzXG4gICAgYTEgPSBsMVsxXVsxXSAtIGwxWzBdWzFdO1xuICAgIGIxID0gbDFbMF1bMF0gLSBsMVsxXVswXTtcbiAgICBjMSA9IGExICogbDFbMF1bMF0gKyBiMSAqIGwxWzBdWzFdO1xuICAgIGEyID0gbDJbMV1bMV0gLSBsMlswXVsxXTtcbiAgICBiMiA9IGwyWzBdWzBdIC0gbDJbMV1bMF07XG4gICAgYzIgPSBhMiAqIGwyWzBdWzBdICsgYjIgKiBsMlswXVsxXTtcbiAgICBkZXQgPSBhMSAqIGIyIC0gYTIqYjE7XG4gICAgaWYgKCFzY2FsYXJfZXEoZGV0LCAwLCBwcmVjaXNpb24pKSB7IC8vIGxpbmVzIGFyZSBub3QgcGFyYWxsZWxcbiAgICAgICAgaVswXSA9IChiMiAqIGMxIC0gYjEgKiBjMikgLyBkZXQ7XG4gICAgICAgIGlbMV0gPSAoYTEgKiBjMiAtIGEyICogYzEpIC8gZGV0O1xuICAgIH1cbiAgICByZXR1cm4gaTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0cy5cbiAqIEBtZXRob2Qgc2VnbWVudHNJbnRlcnNlY3RcbiAqIEBwYXJhbSB7QXJyYXl9IHAxIFRoZSBzdGFydCB2ZXJ0ZXggb2YgdGhlIGZpcnN0IGxpbmUgc2VnbWVudC5cbiAqIEBwYXJhbSB7QXJyYXl9IHAyIFRoZSBlbmQgdmVydGV4IG9mIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuXG4gKiBAcGFyYW0ge0FycmF5fSBxMSBUaGUgc3RhcnQgdmVydGV4IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LlxuICogQHBhcmFtIHtBcnJheX0gcTIgVGhlIGVuZCB2ZXJ0ZXggb2YgdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSB0d28gbGluZSBzZWdtZW50cyBpbnRlcnNlY3RcbiAqL1xuZnVuY3Rpb24gbGluZVNlZ21lbnRzSW50ZXJzZWN0KHAxLCBwMiwgcTEsIHEyKXtcblx0dmFyIGR4ID0gcDJbMF0gLSBwMVswXTtcblx0dmFyIGR5ID0gcDJbMV0gLSBwMVsxXTtcblx0dmFyIGRhID0gcTJbMF0gLSBxMVswXTtcblx0dmFyIGRiID0gcTJbMV0gLSBxMVsxXTtcblxuXHQvLyBzZWdtZW50cyBhcmUgcGFyYWxsZWxcblx0aWYoKGRhKmR5IC0gZGIqZHgpID09PSAwKXtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgcyA9IChkeCAqIChxMVsxXSAtIHAxWzFdKSArIGR5ICogKHAxWzBdIC0gcTFbMF0pKSAvIChkYSAqIGR5IC0gZGIgKiBkeCk7XG5cdHZhciB0ID0gKGRhICogKHAxWzFdIC0gcTFbMV0pICsgZGIgKiAocTFbMF0gLSBwMVswXSkpIC8gKGRiICogZHggLSBkYSAqIGR5KTtcblxuXHRyZXR1cm4gKHM+PTAgJiYgczw9MSAmJiB0Pj0wICYmIHQ8PTEpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYXJlYSBvZiBhIHRyaWFuZ2xlIHNwYW5uZWQgYnkgdGhlIHRocmVlIGdpdmVuIHBvaW50cy4gTm90ZSB0aGF0IHRoZSBhcmVhIHdpbGwgYmUgbmVnYXRpdmUgaWYgdGhlIHBvaW50cyBhcmUgbm90IGdpdmVuIGluIGNvdW50ZXItY2xvY2t3aXNlIG9yZGVyLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBhcmVhXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7QXJyYXl9IGJcbiAqIEBwYXJhbSAge0FycmF5fSBjXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHRyaWFuZ2xlQXJlYShhLGIsYyl7XG4gICAgcmV0dXJuICgoKGJbMF0gLSBhWzBdKSooY1sxXSAtIGFbMV0pKS0oKGNbMF0gLSBhWzBdKSooYlsxXSAtIGFbMV0pKSk7XG59XG5cbmZ1bmN0aW9uIGlzTGVmdChhLGIsYyl7XG4gICAgcmV0dXJuIHRyaWFuZ2xlQXJlYShhLGIsYykgPiAwO1xufVxuXG5mdW5jdGlvbiBpc0xlZnRPbihhLGIsYykge1xuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPj0gMDtcbn1cblxuZnVuY3Rpb24gaXNSaWdodChhLGIsYykge1xuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPCAwO1xufVxuXG5mdW5jdGlvbiBpc1JpZ2h0T24oYSxiLGMpIHtcbiAgICByZXR1cm4gdHJpYW5nbGVBcmVhKGEsIGIsIGMpIDw9IDA7XG59XG5cbnZhciB0bXBQb2ludDEgPSBbXSxcbiAgICB0bXBQb2ludDIgPSBbXTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aHJlZSBwb2ludHMgYXJlIGNvbGxpbmVhclxuICogQG1ldGhvZCBjb2xsaW5lYXJcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHBhcmFtICB7QXJyYXl9IGNcbiAqIEBwYXJhbSAge051bWJlcn0gW3RocmVzaG9sZEFuZ2xlPTBdIFRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBjb21wYXJpbmcgdGhlIHZlY3RvcnMuIFRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0cnVlIGlmIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSByZXN1bHRpbmcgdmVjdG9ycyBpcyBsZXNzIHRoYW4gdGhpcyB2YWx1ZS4gVXNlIHplcm8gZm9yIG1heCBwcmVjaXNpb24uXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBjb2xsaW5lYXIoYSxiLGMsdGhyZXNob2xkQW5nbGUpIHtcbiAgICBpZighdGhyZXNob2xkQW5nbGUpe1xuICAgICAgICByZXR1cm4gdHJpYW5nbGVBcmVhKGEsIGIsIGMpID09PSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhYiA9IHRtcFBvaW50MSxcbiAgICAgICAgICAgIGJjID0gdG1wUG9pbnQyO1xuXG4gICAgICAgIGFiWzBdID0gYlswXS1hWzBdO1xuICAgICAgICBhYlsxXSA9IGJbMV0tYVsxXTtcbiAgICAgICAgYmNbMF0gPSBjWzBdLWJbMF07XG4gICAgICAgIGJjWzFdID0gY1sxXS1iWzFdO1xuXG4gICAgICAgIHZhciBkb3QgPSBhYlswXSpiY1swXSArIGFiWzFdKmJjWzFdLFxuICAgICAgICAgICAgbWFnQSA9IE1hdGguc3FydChhYlswXSphYlswXSArIGFiWzFdKmFiWzFdKSxcbiAgICAgICAgICAgIG1hZ0IgPSBNYXRoLnNxcnQoYmNbMF0qYmNbMF0gKyBiY1sxXSpiY1sxXSksXG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYWNvcyhkb3QvKG1hZ0EqbWFnQikpO1xuICAgICAgICByZXR1cm4gYW5nbGUgPCB0aHJlc2hvbGRBbmdsZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNxZGlzdChhLGIpe1xuICAgIHZhciBkeCA9IGJbMF0gLSBhWzBdO1xuICAgIHZhciBkeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLyoqXG4gKiBHZXQgYSB2ZXJ0ZXggYXQgcG9zaXRpb24gaS4gSXQgZG9lcyBub3QgbWF0dGVyIGlmIGkgaXMgb3V0IG9mIGJvdW5kcywgdGhpcyBmdW5jdGlvbiB3aWxsIGp1c3QgY3ljbGUuXG4gKiBAbWV0aG9kIGF0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBwb2x5Z29uQXQocG9seWdvbiwgaSl7XG4gICAgdmFyIHMgPSBwb2x5Z29uLmxlbmd0aDtcbiAgICByZXR1cm4gcG9seWdvbltpIDwgMCA/IGkgJSBzICsgcyA6IGkgJSBzXTtcbn1cblxuLyoqXG4gKiBDbGVhciB0aGUgcG9seWdvbiBkYXRhXG4gKiBAbWV0aG9kIGNsZWFyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkNsZWFyKHBvbHlnb24pe1xuICAgIHBvbHlnb24ubGVuZ3RoID0gMDtcbn1cblxuLyoqXG4gKiBBcHBlbmQgcG9pbnRzIFwiZnJvbVwiIHRvIFwidG9cIi0xIGZyb20gYW4gb3RoZXIgcG9seWdvbiBcInBvbHlcIiBvbnRvIHRoaXMgb25lLlxuICogQG1ldGhvZCBhcHBlbmRcbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seSBUaGUgcG9seWdvbiB0byBnZXQgcG9pbnRzIGZyb20uXG4gKiBAcGFyYW0ge051bWJlcn0gIGZyb20gVGhlIHZlcnRleCBpbmRleCBpbiBcInBvbHlcIi5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgdG8gVGhlIGVuZCB2ZXJ0ZXggaW5kZXggaW4gXCJwb2x5XCIuIE5vdGUgdGhhdCB0aGlzIHZlcnRleCBpcyBOT1QgaW5jbHVkZWQgd2hlbiBhcHBlbmRpbmcuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkFwcGVuZChwb2x5Z29uLCBwb2x5LCBmcm9tLCB0byl7XG4gICAgZm9yKHZhciBpPWZyb207IGk8dG87IGkrKyl7XG4gICAgICAgIHBvbHlnb24ucHVzaChwb2x5W2ldKTtcbiAgICB9XG59XG5cbi8qKlxuICogTWFrZSBzdXJlIHRoYXQgdGhlIHBvbHlnb24gdmVydGljZXMgYXJlIG9yZGVyZWQgY291bnRlci1jbG9ja3dpc2UuXG4gKiBAbWV0aG9kIG1ha2VDQ1dcbiAqL1xuZnVuY3Rpb24gcG9seWdvbk1ha2VDQ1cocG9seWdvbil7XG4gICAgdmFyIGJyID0gMCxcbiAgICAgICAgdiA9IHBvbHlnb247XG5cbiAgICAvLyBmaW5kIGJvdHRvbSByaWdodCBwb2ludFxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9seWdvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodltpXVsxXSA8IHZbYnJdWzFdIHx8ICh2W2ldWzFdID09PSB2W2JyXVsxXSAmJiB2W2ldWzBdID4gdlticl1bMF0pKSB7XG4gICAgICAgICAgICBiciA9IGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXZlcnNlIHBvbHkgaWYgY2xvY2t3aXNlXG4gICAgaWYgKCFpc0xlZnQocG9seWdvbkF0KHBvbHlnb24sIGJyIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBiciksIHBvbHlnb25BdChwb2x5Z29uLCBiciArIDEpKSkge1xuICAgICAgICBwb2x5Z29uUmV2ZXJzZShwb2x5Z29uKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV2ZXJzZSB0aGUgdmVydGljZXMgaW4gdGhlIHBvbHlnb25cbiAqIEBtZXRob2QgcmV2ZXJzZVxuICovXG5mdW5jdGlvbiBwb2x5Z29uUmV2ZXJzZShwb2x5Z29uKXtcbiAgICB2YXIgdG1wID0gW107XG4gICAgdmFyIE4gPSBwb2x5Z29uLmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHRtcC5wdXNoKHBvbHlnb24ucG9wKCkpO1xuICAgIH1cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG5cdFx0cG9seWdvbltpXSA9IHRtcFtpXTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBwb2ludCBpbiB0aGUgcG9seWdvbiBpcyBhIHJlZmxleCBwb2ludFxuICogQG1ldGhvZCBpc1JlZmxleFxuICogQHBhcmFtICB7TnVtYmVyfSAgaVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbklzUmVmbGV4KHBvbHlnb24sIGkpe1xuICAgIHJldHVybiBpc1JpZ2h0KHBvbHlnb25BdChwb2x5Z29uLCBpIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBpKSwgcG9seWdvbkF0KHBvbHlnb24sIGkgKyAxKSk7XG59XG5cbnZhciB0bXBMaW5lMT1bXSxcbiAgICB0bXBMaW5lMj1bXTtcblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmVydGljZXMgaW4gdGhlIHBvbHlnb24gY2FuIHNlZSBlYWNoIG90aGVyXG4gKiBAbWV0aG9kIGNhblNlZVxuICogQHBhcmFtICB7TnVtYmVyfSBhIFZlcnRleCBpbmRleCAxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGIgVmVydGV4IGluZGV4IDJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25DYW5TZWUocG9seWdvbiwgYSxiKSB7XG4gICAgdmFyIHAsIGRpc3QsIGwxPXRtcExpbmUxLCBsMj10bXBMaW5lMjtcblxuICAgIGlmIChpc0xlZnRPbihwb2x5Z29uQXQocG9seWdvbiwgYSArIDEpLCBwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5Z29uLCBhIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcG9seWdvbkF0KHBvbHlnb24sIGIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRpc3QgPSBzcWRpc3QocG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYikpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBwb2x5Z29uLmxlbmd0aDsgKytpKSB7IC8vIGZvciBlYWNoIGVkZ2VcbiAgICAgICAgaWYgKChpICsgMSkgJSBwb2x5Z29uLmxlbmd0aCA9PT0gYSB8fCBpID09PSBhKXsgLy8gaWdub3JlIGluY2lkZW50IGVkZ2VzXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMZWZ0T24ocG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYiksIHBvbHlnb25BdChwb2x5Z29uLCBpICsgMSkpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSwgcG9seWdvbkF0KHBvbHlnb24sIGkpKSkgeyAvLyBpZiBkaWFnIGludGVyc2VjdHMgYW4gZWRnZVxuICAgICAgICAgICAgbDFbMF0gPSBwb2x5Z29uQXQocG9seWdvbiwgYSk7XG4gICAgICAgICAgICBsMVsxXSA9IHBvbHlnb25BdChwb2x5Z29uLCBiKTtcbiAgICAgICAgICAgIGwyWzBdID0gcG9seWdvbkF0KHBvbHlnb24sIGkpO1xuICAgICAgICAgICAgbDJbMV0gPSBwb2x5Z29uQXQocG9seWdvbiwgaSArIDEpO1xuICAgICAgICAgICAgcCA9IGxpbmVJbnQobDEsbDIpO1xuICAgICAgICAgICAgaWYgKHNxZGlzdChwb2x5Z29uQXQocG9seWdvbiwgYSksIHApIDwgZGlzdCkgeyAvLyBpZiBlZGdlIGlzIGJsb2NraW5nIHZpc2liaWxpdHkgdG8gYlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvcHkgdGhlIHBvbHlnb24gZnJvbSB2ZXJ0ZXggaSB0byB2ZXJ0ZXggai5cbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEBwYXJhbSAge1BvbHlnb259IFt0YXJnZXRQb2x5XSAgIE9wdGlvbmFsIHRhcmdldCBwb2x5Z29uIHRvIHNhdmUgaW4uXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSAgICAgICAgICAgICAgICBUaGUgcmVzdWx0aW5nIGNvcHkuXG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25Db3B5KHBvbHlnb24sIGksaix0YXJnZXRQb2x5KXtcbiAgICB2YXIgcCA9IHRhcmdldFBvbHkgfHwgW107XG4gICAgcG9seWdvbkNsZWFyKHApO1xuICAgIGlmIChpIDwgaikge1xuICAgICAgICAvLyBJbnNlcnQgYWxsIHZlcnRpY2VzIGZyb20gaSB0byBqXG4gICAgICAgIGZvcih2YXIgaz1pOyBrPD1qOyBrKyspe1xuICAgICAgICAgICAgcC5wdXNoKHBvbHlnb25ba10pO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIEluc2VydCB2ZXJ0aWNlcyAwIHRvIGpcbiAgICAgICAgZm9yKHZhciBrPTA7IGs8PWo7IGsrKyl7XG4gICAgICAgICAgICBwLnB1c2gocG9seWdvbltrXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnNlcnQgdmVydGljZXMgaSB0byBlbmRcbiAgICAgICAgZm9yKHZhciBrPWk7IGs8cG9seWdvbi5sZW5ndGg7IGsrKyl7XG4gICAgICAgICAgICBwLnB1c2gocG9seWdvbltrXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbn1cblxuLyoqXG4gKiBEZWNvbXBvc2VzIHRoZSBwb2x5Z29uIGludG8gY29udmV4IHBpZWNlcy4gUmV0dXJucyBhIGxpc3Qgb2YgZWRnZXMgW1twMSxwMl0sW3AyLHAzXSwuLi5dIHRoYXQgY3V0cyB0aGUgcG9seWdvbi5cbiAqIE5vdGUgdGhhdCB0aGlzIGFsZ29yaXRobSBoYXMgY29tcGxleGl0eSBPKE5eNCkgYW5kIHdpbGwgYmUgdmVyeSBzbG93IGZvciBwb2x5Z29ucyB3aXRoIG1hbnkgdmVydGljZXMuXG4gKiBAbWV0aG9kIGdldEN1dEVkZ2VzXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkdldEN1dEVkZ2VzKHBvbHlnb24pIHtcbiAgICB2YXIgbWluPVtdLCB0bXAxPVtdLCB0bXAyPVtdLCB0bXBQb2x5ID0gW107XG4gICAgdmFyIG5EaWFncyA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb24ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHBvbHlnb25Jc1JlZmxleChwb2x5Z29uLCBpKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2x5Z29uLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvbHlnb25DYW5TZWUocG9seWdvbiwgaSwgaikpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wMSA9IHBvbHlnb25HZXRDdXRFZGdlcyhwb2x5Z29uQ29weShwb2x5Z29uLCBpLCBqLCB0bXBQb2x5KSk7XG4gICAgICAgICAgICAgICAgICAgIHRtcDIgPSBwb2x5Z29uR2V0Q3V0RWRnZXMocG9seWdvbkNvcHkocG9seWdvbiwgaiwgaSwgdG1wUG9seSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaz0wOyBrPHRtcDIubGVuZ3RoOyBrKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wMS5wdXNoKHRtcDJba10pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtcDEubGVuZ3RoIDwgbkRpYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSB0bXAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbkRpYWdzID0gdG1wMS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4ucHVzaChbcG9seWdvbkF0KHBvbHlnb24sIGkpLCBwb2x5Z29uQXQocG9seWdvbiwgaildKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtaW47XG59XG5cbi8qKlxuICogRGVjb21wb3NlcyB0aGUgcG9seWdvbiBpbnRvIG9uZSBvciBtb3JlIGNvbnZleCBzdWItUG9seWdvbnMuXG4gKiBAbWV0aG9kIGRlY29tcFxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9yIFBvbHlnb24gb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkRlY29tcChwb2x5Z29uKXtcbiAgICB2YXIgZWRnZXMgPSBwb2x5Z29uR2V0Q3V0RWRnZXMocG9seWdvbik7XG4gICAgaWYoZWRnZXMubGVuZ3RoID4gMCl7XG4gICAgICAgIHJldHVybiBwb2x5Z29uU2xpY2UocG9seWdvbiwgZWRnZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbcG9seWdvbl07XG4gICAgfVxufVxuXG4vKipcbiAqIFNsaWNlcyB0aGUgcG9seWdvbiBnaXZlbiBvbmUgb3IgbW9yZSBjdXQgZWRnZXMuIElmIGdpdmVuIG9uZSwgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0d28gcG9seWdvbnMgKGZhbHNlIG9uIGZhaWx1cmUpLiBJZiBtYW55LCBhbiBhcnJheSBvZiBwb2x5Z29ucy5cbiAqIEBtZXRob2Qgc2xpY2VcbiAqIEBwYXJhbSB7QXJyYXl9IGN1dEVkZ2VzIEEgbGlzdCBvZiBlZGdlcywgYXMgcmV0dXJuZWQgYnkgLmdldEN1dEVkZ2VzKClcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBwb2x5Z29uU2xpY2UocG9seWdvbiwgY3V0RWRnZXMpe1xuICAgIGlmKGN1dEVkZ2VzLmxlbmd0aCA9PT0gMCl7XG5cdFx0cmV0dXJuIFtwb2x5Z29uXTtcbiAgICB9XG4gICAgaWYoY3V0RWRnZXMgaW5zdGFuY2VvZiBBcnJheSAmJiBjdXRFZGdlcy5sZW5ndGggJiYgY3V0RWRnZXNbMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBjdXRFZGdlc1swXS5sZW5ndGg9PT0yICYmIGN1dEVkZ2VzWzBdWzBdIGluc3RhbmNlb2YgQXJyYXkpe1xuXG4gICAgICAgIHZhciBwb2x5cyA9IFtwb2x5Z29uXTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxjdXRFZGdlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgY3V0RWRnZSA9IGN1dEVkZ2VzW2ldO1xuICAgICAgICAgICAgLy8gQ3V0IGFsbCBwb2x5c1xuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8cG9seXMubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgICAgIHZhciBwb2x5ID0gcG9seXNbal07XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBvbHlnb25TbGljZShwb2x5LCBjdXRFZGdlKTtcbiAgICAgICAgICAgICAgICBpZihyZXN1bHQpe1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBwb2x5ISBDdXQgYW5kIHF1aXRcbiAgICAgICAgICAgICAgICAgICAgcG9seXMuc3BsaWNlKGosMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlzLnB1c2gocmVzdWx0WzBdLHJlc3VsdFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2x5cztcbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIFdhcyBnaXZlbiBvbmUgZWRnZVxuICAgICAgICB2YXIgY3V0RWRnZSA9IGN1dEVkZ2VzO1xuICAgICAgICB2YXIgaSA9IHBvbHlnb24uaW5kZXhPZihjdXRFZGdlWzBdKTtcbiAgICAgICAgdmFyIGogPSBwb2x5Z29uLmluZGV4T2YoY3V0RWRnZVsxXSk7XG5cbiAgICAgICAgaWYoaSAhPT0gLTEgJiYgaiAhPT0gLTEpe1xuICAgICAgICAgICAgcmV0dXJuIFtwb2x5Z29uQ29weShwb2x5Z29uLCBpLGopLFxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQ29weShwb2x5Z29uLCBqLGkpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgdGhhdCB0aGUgbGluZSBzZWdtZW50cyBvZiB0aGlzIHBvbHlnb24gZG8gbm90IGludGVyc2VjdCBlYWNoIG90aGVyLlxuICogQG1ldGhvZCBpc1NpbXBsZVxuICogQHBhcmFtICB7QXJyYXl9IHBhdGggQW4gYXJyYXkgb2YgdmVydGljZXMgZS5nLiBbWzAsMF0sWzAsMV0sLi4uXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEB0b2RvIFNob3VsZCBpdCBjaGVjayBhbGwgc2VnbWVudHMgd2l0aCBhbGwgb3RoZXJzP1xuICovXG5mdW5jdGlvbiBwb2x5Z29uSXNTaW1wbGUocG9seWdvbil7XG4gICAgdmFyIHBhdGggPSBwb2x5Z29uLCBpO1xuICAgIC8vIENoZWNrXG4gICAgZm9yKGk9MDsgaTxwYXRoLmxlbmd0aC0xOyBpKyspe1xuICAgICAgICBmb3IodmFyIGo9MDsgajxpLTE7IGorKyl7XG4gICAgICAgICAgICBpZihsaW5lU2VnbWVudHNJbnRlcnNlY3QocGF0aFtpXSwgcGF0aFtpKzFdLCBwYXRoW2pdLCBwYXRoW2orMV0gKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdGhlIHNlZ21lbnQgYmV0d2VlbiB0aGUgbGFzdCBhbmQgdGhlIGZpcnN0IHBvaW50IHRvIGFsbCBvdGhlcnNcbiAgICBmb3IoaT0xOyBpPHBhdGgubGVuZ3RoLTI7IGkrKyl7XG4gICAgICAgIGlmKGxpbmVTZWdtZW50c0ludGVyc2VjdChwYXRoWzBdLCBwYXRoW3BhdGgubGVuZ3RoLTFdLCBwYXRoW2ldLCBwYXRoW2krMV0gKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocDEsIHAyLCBxMSwgcTIsIGRlbHRhKXtcblx0ZGVsdGEgPSBkZWx0YSB8fCAwO1xuXHR2YXIgYTEgPSBwMlsxXSAtIHAxWzFdO1xuXHR2YXIgYjEgPSBwMVswXSAtIHAyWzBdO1xuXHR2YXIgYzEgPSAoYTEgKiBwMVswXSkgKyAoYjEgKiBwMVsxXSk7XG5cdHZhciBhMiA9IHEyWzFdIC0gcTFbMV07XG5cdHZhciBiMiA9IHExWzBdIC0gcTJbMF07XG5cdHZhciBjMiA9IChhMiAqIHExWzBdKSArIChiMiAqIHExWzFdKTtcblx0dmFyIGRldCA9IChhMSAqIGIyKSAtIChhMiAqIGIxKTtcblxuXHRpZighc2NhbGFyX2VxKGRldCwwLGRlbHRhKSl7XG5cdFx0cmV0dXJuIFsoKGIyICogYzEpIC0gKGIxICogYzIpKSAvIGRldCwgKChhMSAqIGMyKSAtIChhMiAqIGMxKSkgLyBkZXRdO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBbMCwwXTtcbiAgICB9XG59XG5cbi8qKlxuICogUXVpY2tseSBkZWNvbXBvc2UgdGhlIFBvbHlnb24gaW50byBjb252ZXggc3ViLXBvbHlnb25zLlxuICogQG1ldGhvZCBxdWlja0RlY29tcFxuICogQHBhcmFtICB7QXJyYXl9IHJlc3VsdFxuICogQHBhcmFtICB7QXJyYXl9IFtyZWZsZXhWZXJ0aWNlc11cbiAqIEBwYXJhbSAge0FycmF5fSBbc3RlaW5lclBvaW50c11cbiAqIEBwYXJhbSAge051bWJlcn0gW2RlbHRhXVxuICogQHBhcmFtICB7TnVtYmVyfSBbbWF4bGV2ZWxdXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtsZXZlbF1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBwb2x5Z29uUXVpY2tEZWNvbXAocG9seWdvbiwgcmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpe1xuICAgIG1heGxldmVsID0gbWF4bGV2ZWwgfHwgMTAwO1xuICAgIGxldmVsID0gbGV2ZWwgfHwgMDtcbiAgICBkZWx0YSA9IGRlbHRhIHx8IDI1O1xuICAgIHJlc3VsdCA9IHR5cGVvZihyZXN1bHQpIT09XCJ1bmRlZmluZWRcIiA/IHJlc3VsdCA6IFtdO1xuICAgIHJlZmxleFZlcnRpY2VzID0gcmVmbGV4VmVydGljZXMgfHwgW107XG4gICAgc3RlaW5lclBvaW50cyA9IHN0ZWluZXJQb2ludHMgfHwgW107XG5cbiAgICB2YXIgdXBwZXJJbnQ9WzAsMF0sIGxvd2VySW50PVswLDBdLCBwPVswLDBdOyAvLyBQb2ludHNcbiAgICB2YXIgdXBwZXJEaXN0PTAsIGxvd2VyRGlzdD0wLCBkPTAsIGNsb3Nlc3REaXN0PTA7IC8vIHNjYWxhcnNcbiAgICB2YXIgdXBwZXJJbmRleD0wLCBsb3dlckluZGV4PTAsIGNsb3Nlc3RJbmRleD0wOyAvLyBJbnRlZ2Vyc1xuICAgIHZhciBsb3dlclBvbHk9W10sIHVwcGVyUG9seT1bXTsgLy8gcG9seWdvbnNcbiAgICB2YXIgcG9seSA9IHBvbHlnb24sXG4gICAgICAgIHYgPSBwb2x5Z29uO1xuXG4gICAgaWYodi5sZW5ndGggPCAzKXtcblx0XHRyZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGxldmVsKys7XG4gICAgaWYobGV2ZWwgPiBtYXhsZXZlbCl7XG4gICAgICAgIGNvbnNvbGUud2FybihcInF1aWNrRGVjb21wOiBtYXggbGV2ZWwgKFwiK21heGxldmVsK1wiKSByZWFjaGVkLlwiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb24ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHBvbHlnb25Jc1JlZmxleChwb2x5LCBpKSkge1xuICAgICAgICAgICAgcmVmbGV4VmVydGljZXMucHVzaChwb2x5W2ldKTtcbiAgICAgICAgICAgIHVwcGVyRGlzdCA9IGxvd2VyRGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG5cblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2x5Z29uLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGVmdChwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5LCBpIC0gMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGogLSAxKSkpIHsgLy8gaWYgbGluZSBpbnRlcnNlY3RzIHdpdGggYW4gZWRnZVxuICAgICAgICAgICAgICAgICAgICBwID0gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaiksIHBvbHlnb25BdChwb2x5LCBqIC0gMSkpOyAvLyBmaW5kIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmlnaHQocG9seWdvbkF0KHBvbHksIGkgKyAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwKSkgeyAvLyBtYWtlIHN1cmUgaXQncyBpbnNpZGUgdGhlIHBvbHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBzcWRpc3QocG9seVtpXSwgcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IGxvd2VyRGlzdCkgeyAvLyBrZWVwIG9ubHkgdGhlIGNsb3Nlc3QgaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJEaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckludCA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJbmRleCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzTGVmdChwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqICsgMSkpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IGdldEludGVyc2VjdGlvblBvaW50KHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopLCBwb2x5Z29uQXQocG9seSwgaiArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGVmdChwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gc3FkaXN0KHBvbHlbaV0sIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCB1cHBlckRpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckRpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVySW50ID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIHZlcnRpY2VzIHRvIGNvbm5lY3QgdG8sIGNob29zZSBhIHBvaW50IGluIHRoZSBtaWRkbGVcbiAgICAgICAgICAgIGlmIChsb3dlckluZGV4ID09PSAodXBwZXJJbmRleCArIDEpICUgcG9seWdvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2FzZSAxOiBWZXJ0ZXgoXCIraStcIiksIGxvd2VySW5kZXgoXCIrbG93ZXJJbmRleCtcIiksIHVwcGVySW5kZXgoXCIrdXBwZXJJbmRleCtcIiksIHBvbHkuc2l6ZShcIitwb2x5Z29uLmxlbmd0aCtcIilcIik7XG4gICAgICAgICAgICAgICAgcFswXSA9IChsb3dlckludFswXSArIHVwcGVySW50WzBdKSAvIDI7XG4gICAgICAgICAgICAgICAgcFsxXSA9IChsb3dlckludFsxXSArIHVwcGVySW50WzFdKSAvIDI7XG4gICAgICAgICAgICAgICAgc3RlaW5lclBvaW50cy5wdXNoKHApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPCB1cHBlckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vbG93ZXJQb2x5Lmluc2VydChsb3dlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGksIHBvbHkuYmVnaW4oKSArIHVwcGVySW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZChsb3dlclBvbHksIHBvbHksIGksIHVwcGVySW5kZXgrMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VySW5kZXggIT09IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgbG93ZXJJbmRleCwgcG9seS5lbmQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSxsb3dlckluZGV4LHBvbHkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCksIHBvbHkuYmVnaW4oKSArIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksMCxpKzEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbG93ZXJQb2x5Lmluc2VydChsb3dlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGksIHBvbHkuZW5kKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZChsb3dlclBvbHksIHBvbHksaSxwb2x5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpLCBwb2x5LmJlZ2luKCkgKyB1cHBlckluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LDAsdXBwZXJJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBsb3dlckluZGV4LCBwb2x5LmJlZ2luKCkgKyBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LGxvd2VySW5kZXgsaSsxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3QgdG8gdGhlIGNsb3Nlc3QgcG9pbnQgd2l0aGluIHRoZSB0cmlhbmdsZVxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDYXNlIDI6IFZlcnRleChcIitpK1wiKSwgY2xvc2VzdEluZGV4KFwiK2Nsb3Nlc3RJbmRleCtcIiksIHBvbHkuc2l6ZShcIitwb2x5Z29uLmxlbmd0aCtcIilcXG5cIik7XG5cbiAgICAgICAgICAgICAgICBpZiAobG93ZXJJbmRleCA+IHVwcGVySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJJbmRleCArPSBwb2x5Z29uLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgICAgICAgICAgaWYodXBwZXJJbmRleCA8IGxvd2VySW5kZXgpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBsb3dlckluZGV4OyBqIDw9IHVwcGVySW5kZXg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0T24ocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBzcWRpc3QocG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBjbG9zZXN0RGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSBqICUgcG9seWdvbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA8IGNsb3Nlc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSxpLGNsb3Nlc3RJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RJbmRleCAhPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSxjbG9zZXN0SW5kZXgsdi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LDAsaSsxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSxpLHYubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSwwLGNsb3Nlc3RJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksY2xvc2VzdEluZGV4LGkrMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzb2x2ZSBzbWFsbGVzdCBwb2x5IGZpcnN0XG4gICAgICAgICAgICBpZiAobG93ZXJQb2x5Lmxlbmd0aCA8IHVwcGVyUG9seS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAobG93ZXJQb2x5LHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAodXBwZXJQb2x5LHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9seWdvblF1aWNrRGVjb21wKHVwcGVyUG9seSxyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICAgICAgcG9seWdvblF1aWNrRGVjb21wKGxvd2VyUG9seSxyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnB1c2gocG9seWdvbik7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJlbW92ZSBjb2xsaW5lYXIgcG9pbnRzIGluIHRoZSBwb2x5Z29uLlxuICogQG1ldGhvZCByZW1vdmVDb2xsaW5lYXJQb2ludHNcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl0gVGhlIHRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBkZXRlcm1pbmluZyB3aGV0aGVyIHR3byBlZGdlcyBhcmUgY29sbGluZWFyLiBVc2UgemVybyBmb3IgZmluZXN0IHByZWNpc2lvbi5cbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHJlbW92ZWRcbiAqL1xuZnVuY3Rpb24gcG9seWdvblJlbW92ZUNvbGxpbmVhclBvaW50cyhwb2x5Z29uLCBwcmVjaXNpb24pe1xuICAgIHZhciBudW0gPSAwO1xuICAgIGZvcih2YXIgaT1wb2x5Z29uLmxlbmd0aC0xOyBwb2x5Z29uLmxlbmd0aD4zICYmIGk+PTA7IC0taSl7XG4gICAgICAgIGlmKGNvbGxpbmVhcihwb2x5Z29uQXQocG9seWdvbiwgaS0xKSxwb2x5Z29uQXQocG9seWdvbiwgaSkscG9seWdvbkF0KHBvbHlnb24sIGkrMSkscHJlY2lzaW9uKSl7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG1pZGRsZSBwb2ludFxuICAgICAgICAgICAgcG9seWdvbi5zcGxpY2UoaSVwb2x5Z29uLmxlbmd0aCwxKTtcbiAgICAgICAgICAgIG51bSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHNjYWxhcnMgYXJlIGVxdWFsXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGVxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSAge051bWJlcn0gYlxuICogQHBhcmFtICB7TnVtYmVyfSBbcHJlY2lzaW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc2NhbGFyX2VxKGEsYixwcmVjaXNpb24pe1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuICAgIHJldHVybiBNYXRoLmFicyhhLWIpIDwgcHJlY2lzaW9uO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3BvbHktZGVjb21wL3NyYy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/*!******************************!*\
  !*** ./tilemap-plus/AABB.js ***!
  \******************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar AABB = function () {\n    function AABB(left, top, right, bottom) {\n        _classCallCheck(this, AABB);\n\n        this.left = left === undefined ? Number.POSITIVE_INFINITY : left;\n        this.right = right === undefined ? Number.NEGATIVE_INFINITY : right;\n        this.top = top === undefined ? Number.POSITIVE_INFINITY : top;\n        this.bottom = bottom === undefined ? Number.NEGATIVE_INFINITY : bottom;\n    }\n\n    _createClass(AABB, [{\n        key: \"isEmpty\",\n        value: function isEmpty() {\n            return this.left > this.right || this.top > this.bottom;\n        }\n    }, {\n        key: \"width\",\n        value: function width() {\n            var width = this.right - this.left;\n            return width >= 0 ? width : NaN;\n        }\n    }, {\n        key: \"height\",\n        value: function height() {\n            var height = this.bottom - this.top;\n            return height >= 0 ? height : NaN;\n        }\n    }, {\n        key: \"containsPoint\",\n        value: function containsPoint(point) {\n            return this.left <= point.x && point.x <= this.right && this.top <= point.y && point.y <= this.bottom;\n        }\n    }, {\n        key: \"containsPoints\",\n        value: function containsPoints(points) {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var point = _step.value;\n\n                    if (!this.containsPoint(point)) {\n                        return false;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            return true;\n        }\n    }, {\n        key: \"intersects\",\n        value: function intersects(aabb) {\n            return;\n            this.left <= aabb.right && this.right >= aabb.left && this.top <= aabb.bottom && this.bottom >= aabb.top;\n        }\n    }], [{\n        key: \"fromPoints\",\n        value: function fromPoints(points) {\n            var left = void 0,\n                top = void 0,\n                right = void 0,\n                bottom = void 0;\n            if (Array.isArray(points)) {\n                left = Math.min.apply(Math, _toConsumableArray(points.map(function (point) {\n                    return point.x;\n                })));\n                top = Math.min.apply(Math, _toConsumableArray(points.map(function (point) {\n                    return point.y;\n                })));\n                right = Math.max.apply(Math, _toConsumableArray(points.map(function (point) {\n                    return point.x;\n                })));\n                bottom = Math.max.apply(Math, _toConsumableArray(points.map(function (point) {\n                    return point.y;\n                })));\n            } else {\n                left = points.x;\n                top = points.y;\n                right = points.x;\n                bottom = points.y;\n            }\n            return new AABB(left, top, right, bottom);\n        }\n    }]);\n\n    return AABB;\n}();\n\nexports.default = AABB;\n\n\nvar validateBounds = function validateBounds(left, top, right, bottom) {\n    if (left > right) {\n        throw new Error(\"Right must be greater than Left\");\n    }\n    if (top > bottom) {\n        throw new Error(\"Bottom must be greater than Top\");\n    }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdGlsZW1hcC1wbHVzL0FBQkIuanM/MzkwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBBQUJCIHtcclxuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQgPT09IHVuZGVmaW5lZCA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IGxlZnQ7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0ID09PSB1bmRlZmluZWQgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgOiByaWdodDtcclxuICAgICAgICB0aGlzLnRvcCA9IHRvcCA9PT0gdW5kZWZpbmVkID8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIDogdG9wO1xyXG4gICAgICAgIHRoaXMuYm90dG9tID0gYm90dG9tID09PSB1bmRlZmluZWQgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgOiBib3R0b207XHJcbiAgICB9XHJcblxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0ID4gdGhpcy5yaWdodCB8fCB0aGlzLnRvcCA+IHRoaXMuYm90dG9tO1xyXG4gICAgfVxyXG5cclxuICAgIHdpZHRoKCkge1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5yaWdodCAtIHRoaXMubGVmdDtcclxuICAgICAgICByZXR1cm4gd2lkdGggPj0gMCA/IHdpZHRoIDogTmFOO1xyXG4gICAgfVxyXG5cclxuICAgIGhlaWdodCgpIHtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmJvdHRvbSAtIHRoaXMudG9wO1xyXG4gICAgICAgIHJldHVybiBoZWlnaHQgPj0gMCA/IGhlaWdodCA6IE5hTjtcclxuICAgIH1cclxuXHJcbiAgICBjb250YWluc1BvaW50KHBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdCA8PSBwb2ludC54ICYmIHBvaW50LnggPD0gdGhpcy5yaWdodFxyXG4gICAgICAgICAgICAmJiB0aGlzLnRvcCA8PSBwb2ludC55ICYmIHBvaW50LnkgPD0gdGhpcy5ib3R0b207XHJcbiAgICB9XHJcblxyXG4gICAgY29udGFpbnNQb2ludHMocG9pbnRzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBwb2ludHMpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5zUG9pbnQocG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaW50ZXJzZWN0cyhhYWJiKSB7XHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIHRoaXMubGVmdCA8PSBhYWJiLnJpZ2h0ICYmXHJcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPj0gYWFiYi5sZWZ0ICYmXHJcbiAgICAgICAgICAgIHRoaXMudG9wIDw9IGFhYmIuYm90dG9tICYmXHJcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID49IGFhYmIudG9wO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBmcm9tUG9pbnRzKHBvaW50cykge1xyXG4gICAgICAgIGxldCBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b207XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9pbnRzKSkge1xyXG4gICAgICAgICAgICBsZWZ0ID0gTWF0aC5taW4oLi4ucG9pbnRzLm1hcChwb2ludCA9PiBwb2ludC54KSk7XHJcbiAgICAgICAgICAgIHRvcCA9IE1hdGgubWluKC4uLnBvaW50cy5tYXAocG9pbnQgPT4gcG9pbnQueSkpO1xyXG4gICAgICAgICAgICByaWdodCA9IE1hdGgubWF4KC4uLnBvaW50cy5tYXAocG9pbnQgPT4gcG9pbnQueCkpO1xyXG4gICAgICAgICAgICBib3R0b20gPSBNYXRoLm1heCguLi5wb2ludHMubWFwKHBvaW50ID0+IHBvaW50LnkpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZWZ0ID0gcG9pbnRzLng7XHJcbiAgICAgICAgICAgIHRvcCA9IHBvaW50cy55O1xyXG4gICAgICAgICAgICByaWdodCA9IHBvaW50cy54O1xyXG4gICAgICAgICAgICBib3R0b20gPSBwb2ludHMueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBQUJCKGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IHZhbGlkYXRlQm91bmRzID0gKGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkgPT4ge1xyXG4gICAgaWYgKGxlZnQgPiByaWdodCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJpZ2h0IG11c3QgYmUgZ3JlYXRlciB0aGFuIExlZnRcIik7XHJcbiAgICB9XHJcbiAgICBpZiAodG9wID4gYm90dG9tKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm90dG9tIG11c3QgYmUgZ3JlYXRlciB0aGFuIFRvcFwiKTtcclxuICAgIH1cclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy90aWxlbWFwLXBsdXMvQUFCQi5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBRUE7OztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBSUE7OztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQTFEQTtBQUNBO0FBQ0E7QUEyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n");

/***/ })
/******/ ]);