/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!*****************************************!*\
  !*** ./tilemap-plus/geometry/Vector.js ***!
  \*****************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Vector = function () {\n    function Vector(x, y) {\n        _classCallCheck(this, Vector);\n\n        this.x = x || 0;\n        this.y = y || 0;\n    }\n\n    _createClass(Vector, [{\n        key: \"clone\",\n        value: function clone() {\n            return new Vector(this.x, this.y);\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(vector) {\n            return vector && this.x === vector.x && this.y === vector.y;\n        }\n    }, {\n        key: \"length\",\n        value: function length() {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        }\n    }, {\n        key: \"normalized\",\n        value: function normalized() {\n            var len = this.length();\n            if (len === 0) {\n                return new Vector(0, 0);\n            } else {\n                return new Vector(this.x / len, this.y / len);\n            }\n        }\n    }, {\n        key: \"perpendicular\",\n        value: function perpendicular() {\n            return new Vector(-this.y, this.x);\n        }\n    }, {\n        key: \"rotated\",\n        value: function rotated(angle) {\n            var cos = Math.cos(angle);\n            var sin = Math.sin(angle);\n            return new Vector(cos * this.x + sin * this.y, -sin * this.x + cos * this.y);\n        }\n    }, {\n        key: \"plus\",\n        value: function plus(vector) {\n            return new Vector(this.x + vector.x, this.y + vector.y);\n        }\n    }, {\n        key: \"minus\",\n        value: function minus(vector) {\n            return new Vector(this.x - vector.x, this.y - vector.y);\n        }\n    }, {\n        key: \"dot\",\n        value: function dot(vector) {\n            return this.x * vector.x + this.y * vector.y;\n        }\n    }, {\n        key: \"perpDot\",\n        value: function perpDot(vector) {\n            return this.x * vector.y - this.y * vector.x;\n        }\n    }, {\n        key: \"scale\",\n        value: function scale(factor) {\n            return new Vector(this.x * factor, this.y * factor);\n        }\n    }]);\n\n    return Vector;\n}();\n\nexports.default = Vector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdGlsZW1hcC1wbHVzL2dlb21ldHJ5L1ZlY3Rvci5qcz8wZGFiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih4LCB5KSB7XHJcbiAgICAgICAgdGhpcy54ID0geCB8fCAwO1xyXG4gICAgICAgIHRoaXMueSA9IHkgfHwgMDtcclxuICAgIH1cclxuXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLngsIHRoaXMueSk7XHJcbiAgICB9XHJcblxyXG4gICAgZXF1YWxzKHZlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiB2ZWN0b3IgJiYgdGhpcy54ID09PSB2ZWN0b3IueCAmJiB0aGlzLnkgPT09IHZlY3Rvci55O1xyXG4gICAgfVxyXG5cclxuICAgIGxlbmd0aCgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSlcclxuICAgIH1cclxuXHJcbiAgICBub3JtYWxpemVkKCkge1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoKCk7XHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCAwKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCAvIGxlbiwgdGhpcy55IC8gbGVuKTtcclxuICAgICAgICB9XHJcbiAgICB9ICAgIFxyXG5cclxuICAgIHBlcnBlbmRpY3VsYXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoLXRoaXMueSwgdGhpcy54KTtcclxuICAgIH1cclxuXHJcbiAgICByb3RhdGVkKGFuZ2xlKSB7XHJcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcihjb3MgKiB0aGlzLnggKyBzaW4gKiB0aGlzLnksIC1zaW4gKiB0aGlzLnggKyBjb3MgKiB0aGlzLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHBsdXModmVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54ICsgdmVjdG9yLngsIHRoaXMueSArIHZlY3Rvci55KTtcclxuICAgIH1cclxuXHJcbiAgICBtaW51cyh2ZWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnggLSB2ZWN0b3IueCwgdGhpcy55IC0gdmVjdG9yLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIGRvdCh2ZWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy54ICogdmVjdG9yLnggKyB0aGlzLnkgKiB2ZWN0b3IueTtcclxuICAgIH1cclxuXHJcbiAgICBwZXJwRG90KHZlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnggKiB2ZWN0b3IueSAtIHRoaXMueSAqIHZlY3Rvci54O1xyXG4gICAgfVxyXG5cclxuICAgIHNjYWxlKGZhY3Rvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCAqIGZhY3RvciwgdGhpcy55ICogZmFjdG9yKTtcclxuICAgIH0gICAgXHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RpbGVtYXAtcGx1cy9nZW9tZXRyeS9WZWN0b3IuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUF2REEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/*!***************************************!*\
  !*** ./tilemap-plus/geometry/AABB.js ***!
  \***************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Vector = __webpack_require__(/*! ./Vector */ 0);\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar AABB = function () {\n    function AABB(left, top, right, bottom) {\n        _classCallCheck(this, AABB);\n\n        this.left = left === undefined ? Number.POSITIVE_INFINITY : left;\n        this.right = right === undefined ? Number.NEGATIVE_INFINITY : right;\n        this.top = top === undefined ? Number.POSITIVE_INFINITY : top;\n        this.bottom = bottom === undefined ? Number.NEGATIVE_INFINITY : bottom;\n    }\n\n    _createClass(AABB, [{\n        key: \"isEmpty\",\n        value: function isEmpty() {\n            return this.left > this.right || this.top > this.bottom;\n        }\n    }, {\n        key: \"width\",\n        value: function width() {\n            var width = this.right - this.left;\n            return width >= 0 ? width : NaN;\n        }\n    }, {\n        key: \"height\",\n        value: function height() {\n            var height = this.bottom - this.top;\n            return height >= 0 ? height : NaN;\n        }\n    }, {\n        key: \"centre\",\n        value: function centre() {\n            return new _Vector2.default((this.left + this.right) * 0.5, (this.top + this.bottom) * 0.5);\n        }\n    }, {\n        key: \"containsPoint\",\n        value: function containsPoint(point) {\n            return this.left <= point.x && point.x <= this.right && this.top <= point.y && point.y <= this.bottom;\n        }\n    }, {\n        key: \"containsPoints\",\n        value: function containsPoints(points) {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var point = _step.value;\n\n                    if (!this.containsPoint(point)) {\n                        return false;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            return true;\n        }\n    }, {\n        key: \"intersects\",\n        value: function intersects(aabb) {\n            var result = this.left <= aabb.right && this.right >= aabb.left && this.top <= aabb.bottom && this.bottom >= aabb.top;\n            return result;\n        }\n    }], [{\n        key: \"fromPoints\",\n        value: function fromPoints(points) {\n            var left = Number.POSITIVE_INFINITY,\n                top = Number.POSITIVE_INFINITY,\n                right = Number.NEGATIVE_INFINITY,\n                bottom = Number.NEGATIVE_INFINITY;\n\n            if (Array.isArray(points)) {\n                left = Math.min.apply(Math, _toConsumableArray(points.map(function (point) {\n                    return point.x;\n                })));\n                top = Math.min.apply(Math, _toConsumableArray(points.map(function (point) {\n                    return point.y;\n                })));\n                right = Math.max.apply(Math, _toConsumableArray(points.map(function (point) {\n                    return point.x;\n                })));\n                bottom = Math.max.apply(Math, _toConsumableArray(points.map(function (point) {\n                    return point.y;\n                })));\n            } else {\n                left = points.x;\n                top = points.y;\n                right = points.x;\n                bottom = points.y;\n            }\n            return new AABB(left, top, right, bottom);\n        }\n    }, {\n        key: \"fromAABBs\",\n        value: function fromAABBs(aabbs) {\n            var left = Number.POSITIVE_INFINITY,\n                top = Number.POSITIVE_INFINITY,\n                right = Number.NEGATIVE_INFINITY,\n                bottom = Number.NEGATIVE_INFINITY;\n\n            if (Array.isArray(aabbs)) {\n                left = Math.min.apply(Math, _toConsumableArray(aabbs.map(function (aabb) {\n                    return aabb.left;\n                })));\n                top = Math.min.apply(Math, _toConsumableArray(aabbs.map(function (aabb) {\n                    return aabb.top;\n                })));\n                right = Math.max.apply(Math, _toConsumableArray(aabbs.map(function (aabb) {\n                    return aabb.right;\n                })));\n                bottom = Math.max.apply(Math, _toConsumableArray(aabbs.map(function (aabb) {\n                    return aabb.bottom;\n                })));\n            } else {\n                left = Math.min(left, aabb.left);\n                top = Math.min(top, aabb.top);\n                right = Math.max(right, aabb.right);\n                bottom = Math.max(bottom, aabb.bottom);\n            }\n\n            return new AABB(left, top, right, bottom);\n        }\n    }]);\n\n    return AABB;\n}();\n\nexports.default = AABB;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdGlsZW1hcC1wbHVzL2dlb21ldHJ5L0FBQkIuanM/ZjdiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVmVjdG9yIGZyb20gXCIuL1ZlY3RvclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQUFCQiB7XHJcbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pIHtcclxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0ID09PSB1bmRlZmluZWQgPyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgOiBsZWZ0O1xyXG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodCA9PT0gdW5kZWZpbmVkID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZIDogcmlnaHQ7XHJcbiAgICAgICAgdGhpcy50b3AgPSB0b3AgPT09IHVuZGVmaW5lZCA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IHRvcDtcclxuICAgICAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbSA9PT0gdW5kZWZpbmVkID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZIDogYm90dG9tO1xyXG4gICAgfVxyXG5cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdCA+IHRoaXMucmlnaHQgfHwgdGhpcy50b3AgPiB0aGlzLmJvdHRvbTtcclxuICAgIH1cclxuXHJcbiAgICB3aWR0aCgpIHtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMucmlnaHQgLSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgcmV0dXJuIHdpZHRoID49IDAgPyB3aWR0aCA6IE5hTjtcclxuICAgIH1cclxuXHJcbiAgICBoZWlnaHQoKSB7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5ib3R0b20gLSB0aGlzLnRvcDtcclxuICAgICAgICByZXR1cm4gaGVpZ2h0ID49IDAgPyBoZWlnaHQgOiBOYU47XHJcbiAgICB9XHJcblxyXG4gICAgY2VudHJlKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKCh0aGlzLmxlZnQgKyB0aGlzLnJpZ2h0KSAqIDAuNSwgKHRoaXMudG9wICsgdGhpcy5ib3R0b20pICogMC41KTtcclxuICAgIH1cclxuXHJcbiAgICBjb250YWluc1BvaW50KHBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdCA8PSBwb2ludC54ICYmIHBvaW50LnggPD0gdGhpcy5yaWdodFxyXG4gICAgICAgICAgICAmJiB0aGlzLnRvcCA8PSBwb2ludC55ICYmIHBvaW50LnkgPD0gdGhpcy5ib3R0b207XHJcbiAgICB9XHJcblxyXG4gICAgY29udGFpbnNQb2ludHMocG9pbnRzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBwb2ludHMpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5zUG9pbnQocG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaW50ZXJzZWN0cyhhYWJiKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID1cclxuICAgICAgICAgICAgdGhpcy5sZWZ0IDw9IGFhYmIucmlnaHQgJiZcclxuICAgICAgICAgICAgdGhpcy5yaWdodCA+PSBhYWJiLmxlZnQgJiZcclxuICAgICAgICAgICAgdGhpcy50b3AgPD0gYWFiYi5ib3R0b20gJiZcclxuICAgICAgICAgICAgdGhpcy5ib3R0b20gPj0gYWFiYi50b3A7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZnJvbVBvaW50cyhwb2ludHMpIHtcclxuICAgICAgICBsZXQgbGVmdCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcclxuICAgICAgICAgICAgdG9wID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxyXG4gICAgICAgICAgICByaWdodCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcclxuICAgICAgICAgICAgYm90dG9tID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xyXG5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb2ludHMpKSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1pbiguLi5wb2ludHMubWFwKHBvaW50ID0+IHBvaW50LngpKTtcclxuICAgICAgICAgICAgdG9wID0gTWF0aC5taW4oLi4ucG9pbnRzLm1hcChwb2ludCA9PiBwb2ludC55KSk7XHJcbiAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5tYXgoLi4ucG9pbnRzLm1hcChwb2ludCA9PiBwb2ludC54KSk7XHJcbiAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KC4uLnBvaW50cy5tYXAocG9pbnQgPT4gcG9pbnQueSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSBwb2ludHMueDtcclxuICAgICAgICAgICAgdG9wID0gcG9pbnRzLnk7XHJcbiAgICAgICAgICAgIHJpZ2h0ID0gcG9pbnRzLng7XHJcbiAgICAgICAgICAgIGJvdHRvbSA9IHBvaW50cy55O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEFBQkIobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZnJvbUFBQkJzKGFhYmJzKSB7XHJcbiAgICAgICAgbGV0IGxlZnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXHJcbiAgICAgICAgICAgIHRvcCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcclxuICAgICAgICAgICAgcmlnaHQgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXHJcbiAgICAgICAgICAgIGJvdHRvbSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYWFiYnMpKSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1pbiguLi5hYWJicy5tYXAoYWFiYiA9PiBhYWJiLmxlZnQpKTtcclxuICAgICAgICAgICAgdG9wID0gTWF0aC5taW4oLi4uYWFiYnMubWFwKGFhYmIgPT4gYWFiYi50b3ApKTtcclxuICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1heCguLi5hYWJicy5tYXAoYWFiYiA9PiBhYWJiLnJpZ2h0KSk7XHJcbiAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KC4uLmFhYmJzLm1hcChhYWJiID0+IGFhYmIuYm90dG9tKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGVmdCA9IE1hdGgubWluKGxlZnQsIGFhYmIubGVmdCk7XHJcbiAgICAgICAgICAgIHRvcCA9IE1hdGgubWluKHRvcCwgYWFiYi50b3ApO1xyXG4gICAgICAgICAgICByaWdodCA9IE1hdGgubWF4KHJpZ2h0LCBhYWJiLnJpZ2h0KTtcclxuICAgICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoYm90dG9tLCBhYWJiLmJvdHRvbSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEFBQkIobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKTtcclxuICAgIH1cclxufVxyXG5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy90aWxlbWFwLXBsdXMvZ2VvbWV0cnkvQUFCQi5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBOzs7Ozs7Ozs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUVBOzs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7OztBQUVBO0FBQ0E7QUFLQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUF4RkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/*!************************************************!*\
  !*** ./tilemap-plus/geometry/ConvexPolygon.js ***!
  \************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _polyDecomp = __webpack_require__(/*! poly-decomp */ 8);\n\nvar _polyDecomp2 = _interopRequireDefault(_polyDecomp);\n\nvar _Vector = __webpack_require__(/*! ./Vector */ 0);\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nvar _AABB = __webpack_require__(/*! ./AABB */ 1);\n\nvar _AABB2 = _interopRequireDefault(_AABB);\n\nvar _Range = __webpack_require__(/*! ./Range */ 3);\n\nvar _Range2 = _interopRequireDefault(_Range);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar average = function average(array) {\n    return array.reduce(function (accumulator, value) {\n        return accumulator + value;\n    }, 0) / array.length;\n};\n\nvar validateBounds = function validateBounds(left, top, right, bottom) {\n    if (left > right) {\n        throw new Error(\"Right must be greater than Left\");\n    }\n    if (top > bottom) {\n        throw new Error(\"Bottom must be greater than Top\");\n    }\n};\n\nvar ConvexPolygon = function () {\n    function ConvexPolygon(vertices) {\n        _classCallCheck(this, ConvexPolygon);\n\n        this.vertices = vertices;\n        this.recompute();\n    }\n\n    _createClass(ConvexPolygon, [{\n        key: \"recompute\",\n        value: function recompute() {\n            var vertices = this.vertices;\n            this.aabb = _AABB2.default.fromPoints(vertices);\n            this.edges = [];\n            this.normals = [];\n            this.count = vertices.length;\n            this.centre = new _Vector2.default(average(vertices.map(function (v) {\n                return v.x;\n            })), average(vertices.map(function (v) {\n                return v.y;\n            })));\n\n            if (this.count > 1) {\n                for (var i = 0; i < this.count; i++) {\n                    var j = (i + 1) % this.count;\n                    var edge = vertices[j].minus(vertices[i]);\n                    this.edges.push(edge);\n                    // generate outward normals\n                    var normal = edge.normalized().perpendicular();\n                    var radius = vertices[i].minus(this.centre);\n                    if (radius.dot(normal) < 0) {\n                        normal = normal.scale(-1);\n                    }\n                    this.normals.push(normal);\n                }\n            }\n        }\n    }, {\n        key: \"isValid\",\n        value: function isValid() {\n            if (this.count < 4) {\n                return true;\n            }\n            var prevPerpDot = 0;\n            for (var i = 0; i < this.count; i++) {\n                var j = (i + 1) % this.count;\n                var perpDot = this.edges[i].perpDot(this.edges[j]);\n                if (perpDot * prevPerpDot < 0) {\n                    return false;\n                }\n                prevPerpDot = perpDot;\n            }\n            return true;\n        }\n    }, {\n        key: \"projectOntoAxis\",\n        value: function projectOntoAxis(axis) {\n            var range = new _Range2.default();\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.vertices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var vertex = _step.value;\n\n                    var projection = vertex.dot(axis);\n                    range.extendTo(projection);\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            return range;\n        }\n    }, {\n        key: \"rotated\",\n        value: function rotated(angle) {\n            var rotatedVertices = [];\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this.vertices[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var vertex = _step2.value;\n\n                    var vertexOffset = new _Vector2.default(vertex.x, vertex.y).minus(this.centre);\n                    var rotatedOffset = vertexOffset.rotated(angle);\n                    var rotatedVertex = this.centre.plus(rotatedOffset);\n                    rotatedVertices.push(rotatedVertex);\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            return new ConvexPolygon(rotatedVertices);\n        }\n    }, {\n        key: \"translated\",\n        value: function translated(offset) {\n            var translatedVertices = this.vertices.map(function (vertex) {\n                return vertex.plus(offset);\n            });\n            return new ConvexPolygon(translatedVertices);\n        }\n    }], [{\n        key: \"fromRectangle\",\n        value: function fromRectangle(left, top, right, bottom) {\n            validateBounds(left, top, right, bottom);\n\n            var vertices = [new _Vector2.default(left, top), new _Vector2.default(right, top), new _Vector2.default(right, bottom), new _Vector2.default(left, bottom)];\n            return new ConvexPolygon(vertices);\n        }\n    }, {\n        key: \"fromCapsule\",\n        value: function fromCapsule(left, top, right, bottom, capSegments) {\n            if (capSegments < 3) {\n                throw new Error(\"Specify at least 3 cap segments\");\n            }\n            validateBounds(left, top, right, bottom);\n            var width = right - left;\n            var height = bottom - top;\n            if (height < width) {\n                throw new Error(\"Capsule height must be larger than width\");\n            }\n            var capRadius = width * 0.5;\n            var capAngles = [].concat(_toConsumableArray(Array(capSegments).keys())).map(function (index) {\n                return -index * Math.PI / capSegments;\n            });\n\n            var centreX = (left + right) * 0.5;\n            var capVertices = capAngles.map(function (angle) {\n                return new _Vector2.default(Math.cos(angle), Math.sin(angle)).scale(capRadius);\n            });\n            var topCapFocus = new _Vector2.default(centreX, top + capRadius);\n            var vertices = capVertices.map(function (capVertex) {\n                return topCapFocus.plus(capVertex);\n            });\n            vertices.push(new _Vector2.default(left, topCapFocus.y));\n            var bottomCapFocus = new _Vector2.default(centreX, bottom - capRadius);\n            vertices = vertices.concat(capVertices.map(function (capVertex) {\n                return bottomCapFocus.minus(capVertex);\n            }));\n            vertices.push(new _Vector2.default(right, bottomCapFocus.y));\n\n            return new ConvexPolygon(vertices);\n        }\n    }, {\n        key: \"generateConvexPolygons\",\n        value: function generateConvexPolygons(vertices) {\n            var pdVertices = vertices.map(function (v) {\n                return [v.x, v.y];\n            });\n            var pdConvexPolygons = _polyDecomp2.default.decomp(pdVertices);\n            var convexPolygons = pdConvexPolygons.map(function (pdConvexPolygon) {\n                return new ConvexPolygon(pdConvexPolygon.map(function (pdVertex) {\n                    return new _Vector2.default(pdVertex[0], pdVertex[1]);\n                }));\n            });\n            return convexPolygons;\n        }\n    }]);\n\n    return ConvexPolygon;\n}();\n\nexports.default = ConvexPolygon;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdGlsZW1hcC1wbHVzL2dlb21ldHJ5L0NvbnZleFBvbHlnb24uanM/MjViMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUG9seURlY29tcCBmcm9tIFwicG9seS1kZWNvbXBcIjtcclxuaW1wb3J0IFZlY3RvciBmcm9tIFwiLi9WZWN0b3JcIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4vQUFCQlwiO1xyXG5pbXBvcnQgUmFuZ2UgZnJvbSBcIi4vUmFuZ2VcIjtcclxuXHJcbmNvbnN0IGF2ZXJhZ2UgPSAoYXJyYXkpID0+IGFycmF5LnJlZHVjZSggKCBhY2N1bXVsYXRvciwgdmFsdWUgKSA9PiBhY2N1bXVsYXRvciArIHZhbHVlLCAwICkgLyBhcnJheS5sZW5ndGg7XHJcblxyXG5jb25zdCB2YWxpZGF0ZUJvdW5kcyA9IChsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pID0+IHtcclxuICAgIGlmIChsZWZ0ID4gcmlnaHQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSaWdodCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBMZWZ0XCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRvcCA+IGJvdHRvbSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJvdHRvbSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBUb3BcIik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb252ZXhQb2x5Z29uIHtcclxuICAgIGNvbnN0cnVjdG9yKHZlcnRpY2VzKSB7XHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xyXG4gICAgICAgIHRoaXMucmVjb21wdXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVjb21wdXRlKCkge1xyXG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgICAgICB0aGlzLmFhYmIgPSBBQUJCLmZyb21Qb2ludHModmVydGljZXMpO1xyXG4gICAgICAgIHRoaXMuZWRnZXMgPSBbXTtcclxuICAgICAgICB0aGlzLm5vcm1hbHMgPSBbXTtcclxuICAgICAgICB0aGlzLmNvdW50ID0gdmVydGljZXMubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuY2VudHJlID0gbmV3IFZlY3RvcihcclxuICAgICAgICAgICAgYXZlcmFnZSh2ZXJ0aWNlcy5tYXAodiA9PiB2LngpKSxcclxuICAgICAgICAgICAgYXZlcmFnZSh2ZXJ0aWNlcy5tYXAodiA9PiB2LnkpKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPiAxKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaiA9IChpICsgMSkgJSB0aGlzLmNvdW50O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWRnZSA9IHZlcnRpY2VzW2pdLm1pbnVzKHZlcnRpY2VzW2ldKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWRnZXMucHVzaChlZGdlKTtcclxuICAgICAgICAgICAgICAgIC8vIGdlbmVyYXRlIG91dHdhcmQgbm9ybWFsc1xyXG4gICAgICAgICAgICAgICAgbGV0IG5vcm1hbCA9IGVkZ2Uubm9ybWFsaXplZCgpLnBlcnBlbmRpY3VsYXIoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IHZlcnRpY2VzW2ldLm1pbnVzKHRoaXMuY2VudHJlKTtcclxuICAgICAgICAgICAgICAgIGlmIChyYWRpdXMuZG90KG5vcm1hbCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsID0gbm9ybWFsLnNjYWxlKC0xKTtcclxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vcm1hbHMucHVzaChub3JtYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlzVmFsaWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPCA0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcHJldlBlcnBEb3QgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBqID0gKGkgKyAxKSAlIHRoaXMuY291bnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHBlcnBEb3QgPSB0aGlzLmVkZ2VzW2ldLnBlcnBEb3QodGhpcy5lZGdlc1tqXSk7XHJcbiAgICAgICAgICAgIGlmIChwZXJwRG90ICogcHJldlBlcnBEb3QgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldlBlcnBEb3QgPSBwZXJwRG90O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcm9qZWN0T250b0F4aXMoYXhpcykge1xyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gbmV3IFJhbmdlKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCB2ZXJ0ZXggb2YgdGhpcy52ZXJ0aWNlcykge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0aW9uID0gdmVydGV4LmRvdChheGlzKTtcclxuICAgICAgICAgICAgcmFuZ2UuZXh0ZW5kVG8ocHJvamVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByYW5nZTtcclxuICAgIH1cclxuXHJcbiAgICByb3RhdGVkKGFuZ2xlKSB7XHJcbiAgICAgICAgY29uc3Qgcm90YXRlZFZlcnRpY2VzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCB2ZXJ0ZXggb2YgdGhpcy52ZXJ0aWNlcykge1xyXG4gICAgICAgICAgICBjb25zdCB2ZXJ0ZXhPZmZzZXQgPSBuZXcgVmVjdG9yKHZlcnRleC54LCB2ZXJ0ZXgueSkubWludXModGhpcy5jZW50cmUpO1xyXG4gICAgICAgICAgICBjb25zdCByb3RhdGVkT2Zmc2V0ID0gdmVydGV4T2Zmc2V0LnJvdGF0ZWQoYW5nbGUpO1xyXG4gICAgICAgICAgICBjb25zdCByb3RhdGVkVmVydGV4ID0gdGhpcy5jZW50cmUucGx1cyhyb3RhdGVkT2Zmc2V0KTtcclxuICAgICAgICAgICAgcm90YXRlZFZlcnRpY2VzLnB1c2gocm90YXRlZFZlcnRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQ29udmV4UG9seWdvbihyb3RhdGVkVmVydGljZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRyYW5zbGF0ZWQob2Zmc2V0KSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlZFZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcy5tYXAodmVydGV4ID0+IHZlcnRleC5wbHVzKG9mZnNldCkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29udmV4UG9seWdvbih0cmFuc2xhdGVkVmVydGljZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBmcm9tUmVjdGFuZ2xlKGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xyXG4gICAgICAgIHZhbGlkYXRlQm91bmRzKGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gW1xyXG4gICAgICAgICAgICBuZXcgVmVjdG9yKGxlZnQsIHRvcCksXHJcbiAgICAgICAgICAgIG5ldyBWZWN0b3IocmlnaHQsIHRvcCksXHJcbiAgICAgICAgICAgIG5ldyBWZWN0b3IocmlnaHQsIGJvdHRvbSksXHJcbiAgICAgICAgICAgIG5ldyBWZWN0b3IobGVmdCwgYm90dG9tKVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb252ZXhQb2x5Z29uKHZlcnRpY2VzKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZnJvbUNhcHN1bGUobGVmdCwgdG9wLCByaWdodCwgYm90dG9tLCBjYXBTZWdtZW50cykge1xyXG4gICAgICAgIGlmIChjYXBTZWdtZW50cyA8IDMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3BlY2lmeSBhdCBsZWFzdCAzIGNhcCBzZWdtZW50c1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsaWRhdGVCb3VuZHMobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKTtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7ICAgICAgICBcclxuICAgICAgICBpZiAoaGVpZ2h0IDwgd2lkdGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fwc3VsZSBoZWlnaHQgbXVzdCBiZSBsYXJnZXIgdGhhbiB3aWR0aFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2FwUmFkaXVzID0gd2lkdGggKiAwLjU7XHJcbiAgICAgICAgY29uc3QgY2FwQW5nbGVzID0gWy4uLkFycmF5KGNhcFNlZ21lbnRzKS5rZXlzKCldLm1hcChpbmRleCA9PiAtaW5kZXggKiBNYXRoLlBJIC8gY2FwU2VnbWVudHMpO1xyXG5cclxuICAgICAgICBjb25zdCBjZW50cmVYID0gKGxlZnQgKyByaWdodCkgKiAwLjU7XHJcbiAgICAgICAgY29uc3QgY2FwVmVydGljZXMgPSBjYXBBbmdsZXMubWFwKGFuZ2xlID0+IG5ldyBWZWN0b3IoTWF0aC5jb3MoYW5nbGUpLCBNYXRoLnNpbihhbmdsZSkpLnNjYWxlKGNhcFJhZGl1cykpO1xyXG4gICAgICAgIGNvbnN0IHRvcENhcEZvY3VzID0gbmV3IFZlY3RvcihjZW50cmVYLCB0b3AgKyBjYXBSYWRpdXMpO1xyXG4gICAgICAgIGxldCB2ZXJ0aWNlcyA9IGNhcFZlcnRpY2VzLm1hcChjYXBWZXJ0ZXggPT4gdG9wQ2FwRm9jdXMucGx1cyhjYXBWZXJ0ZXgpKTtcclxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKG5ldyBWZWN0b3IobGVmdCwgdG9wQ2FwRm9jdXMueSkpO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbUNhcEZvY3VzID0gbmV3IFZlY3RvcihjZW50cmVYLCBib3R0b20gLSBjYXBSYWRpdXMpO1xyXG4gICAgICAgIHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KGNhcFZlcnRpY2VzLm1hcChjYXBWZXJ0ZXggPT4gYm90dG9tQ2FwRm9jdXMubWludXMoY2FwVmVydGV4KSkpO1xyXG4gICAgICAgIHZlcnRpY2VzLnB1c2gobmV3IFZlY3RvcihyaWdodCwgYm90dG9tQ2FwRm9jdXMueSkpO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IENvbnZleFBvbHlnb24odmVydGljZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZW5lcmF0ZUNvbnZleFBvbHlnb25zKHZlcnRpY2VzKSB7XHJcbiAgICAgICAgY29uc3QgcGRWZXJ0aWNlcyA9IHZlcnRpY2VzLm1hcCh2ID0+IFt2LngsIHYueV0pO1xyXG4gICAgICAgIGNvbnN0IHBkQ29udmV4UG9seWdvbnMgPSBQb2x5RGVjb21wLmRlY29tcChwZFZlcnRpY2VzKTtcclxuICAgICAgICBjb25zdCBjb252ZXhQb2x5Z29ucyA9IHBkQ29udmV4UG9seWdvbnMubWFwKHBkQ29udmV4UG9seWdvbiA9PlxyXG4gICAgICAgICAgICBuZXcgQ29udmV4UG9seWdvbihwZENvbnZleFBvbHlnb24ubWFwKHBkVmVydGV4ID0+XHJcbiAgICAgICAgICAgICAgICBuZXcgVmVjdG9yKHBkVmVydGV4WzBdLCBwZFZlcnRleFsxXSkpXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBjb252ZXhQb2x5Z29ucztcclxuICAgIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RpbGVtYXAtcGx1cy9nZW9tZXRyeS9Db252ZXhQb2x5Z29uLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7Ozs7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7OztBQUVBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUtBO0FBQ0E7Ozs7OztBQXhIQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/*!****************************************!*\
  !*** ./tilemap-plus/geometry/Range.js ***!
  \****************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Range = function () {\n    function Range() {\n        _classCallCheck(this, Range);\n\n        this.makeEmpty();\n    }\n\n    _createClass(Range, [{\n        key: \"extendTo\",\n        value: function extendTo(point) {\n            if (this.min > point) {\n                this.min = point;\n            }\n            if (this.max < point) {\n                this.max = point;\n            }\n        }\n    }, {\n        key: \"containsPoint\",\n        value: function containsPoint(point) {\n            return this.min <= point && point <= this.max;\n        }\n    }, {\n        key: \"containsRange\",\n        value: function containsRange(range) {\n            return this.min <= range.min && this.max > range.max;\n        }\n    }, {\n        key: \"isEmpty\",\n        value: function isEmpty() {\n            return this.min > this.max;\n        }\n    }, {\n        key: \"makeEmpty\",\n        value: function makeEmpty() {\n            this.min = Number.POSITIVE_INFINITY;\n            this.max = Number.NEGATIVE_INFINITY;\n        }\n    }, {\n        key: \"length\",\n        value: function length() {\n            if (this.min > this.max) {\n                return Number.NaN;\n            }\n            return this.max - this.min;\n        }\n    }], [{\n        key: \"intersection\",\n        value: function intersection(r1, r2) {\n            var range = new Range();\n            range.min = Math.max(r1.min, r2.min);\n            range.max = Math.min(r1.max, r2.max);\n            if (range.min > range.max) {\n                range.makeEmpty();\n            }\n            return range;\n        }\n    }, {\n        key: \"bound\",\n        value: function bound(r1, r2) {\n            var range = new Range();\n            range.min = Math.min(r1.min, r2.min);\n            range.max = Math.max(r1.max, r2.max);\n            return range;\n        }\n    }]);\n\n    return Range;\n}();\n\nexports.default = Range;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdGlsZW1hcC1wbHVzL2dlb21ldHJ5L1JhbmdlLmpzP2RkMmEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFuZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5tYWtlRW1wdHkoKTtcclxuICAgIH1cclxuXHJcbiAgICBleHRlbmRUbyhwb2ludCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1pbiA+IHBvaW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMubWluID0gcG9pbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1heCA8IHBvaW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gcG9pbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taW4gPD0gcG9pbnQgJiYgcG9pbnQgPD0gdGhpcy5tYXg7XHJcbiAgICB9XHJcblxyXG4gICAgY29udGFpbnNSYW5nZShyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1pbiA8PSByYW5nZS5taW4gJiYgdGhpcy5tYXggPiByYW5nZS5tYXg7XHJcbiAgICB9XHJcblxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taW4gPiB0aGlzLm1heDtcclxuICAgIH1cclxuXHJcbiAgICBtYWtlRW1wdHkoKSB7XHJcbiAgICAgICAgdGhpcy5taW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgICAgdGhpcy5tYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XHJcbiAgICB9XHJcblxyXG4gICAgbGVuZ3RoKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1pbiA+IHRoaXMubWF4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTmFOO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5tYXggLSB0aGlzLm1pbjtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgaW50ZXJzZWN0aW9uKHIxLCByMikge1xyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gbmV3IFJhbmdlKCk7XHJcbiAgICAgICAgcmFuZ2UubWluID0gTWF0aC5tYXgocjEubWluLCByMi5taW4pO1xyXG4gICAgICAgIHJhbmdlLm1heCA9IE1hdGgubWluKHIxLm1heCwgcjIubWF4KTtcclxuICAgICAgICBpZiAocmFuZ2UubWluID4gcmFuZ2UubWF4KSB7XHJcbiAgICAgICAgICAgIHJhbmdlLm1ha2VFbXB0eSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmFuZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGJvdW5kKHIxLCByMikge1xyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gbmV3IFJhbmdlKCk7XHJcbiAgICAgICAgcmFuZ2UubWluID0gTWF0aC5taW4ocjEubWluLCByMi5taW4pO1xyXG4gICAgICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHIxLm1heCwgcjIubWF4KTtcclxuICAgICAgICByZXR1cm4gcmFuZ2U7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RpbGVtYXAtcGx1cy9nZW9tZXRyeS9SYW5nZS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBckRBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _TilemapPlus = __webpack_require__(/*! ./tilemap-plus/TilemapPlus */ 5);\n\nvar _TilemapPlus2 = _interopRequireDefault(_TilemapPlus);\n\nvar _TilemapLayerPlus = __webpack_require__(/*! ./tilemap-plus/TilemapLayerPlus */ 13);\n\nvar _TilemapLayerPlus2 = _interopRequireDefault(_TilemapLayerPlus);\n\nvar _TilesetPlus = __webpack_require__(/*! ./tilemap-plus/TilesetPlus */ 14);\n\nvar _TilesetPlus2 = _interopRequireDefault(_TilesetPlus);\n\nvar _SpritePlus = __webpack_require__(/*! ./tilemap-plus/SpritePlus */ 15);\n\nvar _SpritePlus2 = _interopRequireDefault(_SpritePlus);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nPhaser.Plugin.TilemapPlus = function (game, parent) {\n    Phaser.Plugin.call(this, game, parent);\n\n    var originalTilemapLoader = Phaser.Loader.prototype.tilemap;\n    Phaser.Loader.prototype.tilemap = function (key, url, data, format) {\n        originalTilemapLoader.call(this, key, url, data, format);\n        this.json(jsonKey(key), url);\n    };\n\n    var originalTilemapFactory = Phaser.GameObjectFactory.prototype.tilemap;\n    Phaser.GameObjectFactory.prototype.tilemap = function (key, tileWidth, tileHeight, width, height) {\n        var tilemap = originalTilemapFactory.call(this, key, tileWidth, tileHeight, width, height);\n        var tilemapJson = this.game.cache.getJSON(jsonKey(key));\n        tilemap.plus = new _TilemapPlus2.default(tilemapJson, this.game.time, tilemap);\n        return tilemap;\n    };\n\n    var originalTilemapCreateLayer = Phaser.Tilemap.prototype.createLayer;\n    Phaser.Tilemap.prototype.createLayer = function (layer, width, height, group) {\n        var tilemapLayer = originalTilemapCreateLayer.call(this, layer, width, height, group);\n        tilemapLayer.plus = new _TilemapLayerPlus2.default(tilemapLayer);\n        return tilemapLayer;\n    };\n\n    var originalTilemapAddTilesetImage = Phaser.Tilemap.prototype.addTilesetImage;\n    Phaser.Tilemap.prototype.addTilesetImage = function (tileset, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid) {\n        var tilesetImage = originalTilemapAddTilesetImage.call(this, tileset, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid);\n        tilesetImage.plus = new _TilesetPlus2.default(tilesetImage);\n        return tilesetImage;\n    };\n\n    var originalSpriteFactory = Phaser.GameObjectFactory.prototype.sprite;\n    Phaser.GameObjectFactory.prototype.sprite = function (x, y, key, frame, group) {\n        var sprite = originalSpriteFactory.call(this, x, y, key, frame, group);\n        sprite.plus = new _SpritePlus2.default(sprite);\n        return sprite;\n    };\n\n    function jsonKey(key) {\n        return key + \"-TilemapPlus\";\n    }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvaW5kZXguanM/MWZkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVGlsZW1hcFBsdXMgZnJvbSBcIi4vdGlsZW1hcC1wbHVzL1RpbGVtYXBQbHVzXCI7XHJcbmltcG9ydCBUaWxlbWFwTGF5ZXJQbHVzIGZyb20gXCIuL3RpbGVtYXAtcGx1cy9UaWxlbWFwTGF5ZXJQbHVzXCI7XHJcbmltcG9ydCBUaWxlc2V0UGx1cyBmcm9tIFwiLi90aWxlbWFwLXBsdXMvVGlsZXNldFBsdXNcIjtcclxuaW1wb3J0IFNwcml0ZVBsdXMgZnJvbSBcIi4vdGlsZW1hcC1wbHVzL1Nwcml0ZVBsdXNcIjtcclxuXHJcblBoYXNlci5QbHVnaW4uVGlsZW1hcFBsdXMgPSBmdW5jdGlvbiAoZ2FtZSwgcGFyZW50KSB7XHJcblx0UGhhc2VyLlBsdWdpbi5jYWxsKHRoaXMsIGdhbWUsIHBhcmVudCk7XHJcbiAgICBcclxuICAgIGNvbnN0IG9yaWdpbmFsVGlsZW1hcExvYWRlciA9IFBoYXNlci5Mb2FkZXIucHJvdG90eXBlLnRpbGVtYXA7XHJcbiAgICBQaGFzZXIuTG9hZGVyLnByb3RvdHlwZS50aWxlbWFwID0gZnVuY3Rpb24oa2V5LCB1cmwsIGRhdGEsIGZvcm1hdCkge1xyXG4gICAgICAgIG9yaWdpbmFsVGlsZW1hcExvYWRlci5jYWxsKHRoaXMsIGtleSwgdXJsLCBkYXRhLCBmb3JtYXQpO1xyXG4gICAgICAgIHRoaXMuanNvbihqc29uS2V5KGtleSksIHVybCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBjb25zdCBvcmlnaW5hbFRpbGVtYXBGYWN0b3J5ID0gUGhhc2VyLkdhbWVPYmplY3RGYWN0b3J5LnByb3RvdHlwZS50aWxlbWFwO1xyXG4gICAgUGhhc2VyLkdhbWVPYmplY3RGYWN0b3J5LnByb3RvdHlwZS50aWxlbWFwID0gZnVuY3Rpb24oa2V5LCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBjb25zdCB0aWxlbWFwID0gb3JpZ2luYWxUaWxlbWFwRmFjdG9yeS5jYWxsKHRoaXMsIGtleSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICBjb25zdCB0aWxlbWFwSnNvbiA9IHRoaXMuZ2FtZS5jYWNoZS5nZXRKU09OKGpzb25LZXkoa2V5KSk7IFxyXG4gICAgICAgIHRpbGVtYXAucGx1cyA9IG5ldyBUaWxlbWFwUGx1cyh0aWxlbWFwSnNvbiwgdGhpcy5nYW1lLnRpbWUsIHRpbGVtYXApO1xyXG4gICAgICAgIHJldHVybiB0aWxlbWFwO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBvcmlnaW5hbFRpbGVtYXBDcmVhdGVMYXllciA9IFBoYXNlci5UaWxlbWFwLnByb3RvdHlwZS5jcmVhdGVMYXllcjtcclxuICAgIFBoYXNlci5UaWxlbWFwLnByb3RvdHlwZS5jcmVhdGVMYXllciA9IGZ1bmN0aW9uKGxheWVyLCB3aWR0aCwgaGVpZ2h0LCBncm91cCkge1xyXG4gICAgICAgIGNvbnN0IHRpbGVtYXBMYXllciA9IG9yaWdpbmFsVGlsZW1hcENyZWF0ZUxheWVyLmNhbGwodGhpcywgbGF5ZXIsIHdpZHRoLCBoZWlnaHQsIGdyb3VwKTtcclxuICAgICAgICB0aWxlbWFwTGF5ZXIucGx1cyA9IG5ldyBUaWxlbWFwTGF5ZXJQbHVzKHRpbGVtYXBMYXllcik7XHJcbiAgICAgICAgcmV0dXJuIHRpbGVtYXBMYXllcjtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3Qgb3JpZ2luYWxUaWxlbWFwQWRkVGlsZXNldEltYWdlID0gUGhhc2VyLlRpbGVtYXAucHJvdG90eXBlLmFkZFRpbGVzZXRJbWFnZTtcclxuICAgIFBoYXNlci5UaWxlbWFwLnByb3RvdHlwZS5hZGRUaWxlc2V0SW1hZ2UgPSBmdW5jdGlvbih0aWxlc2V0LCBrZXksIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwgdGlsZU1hcmdpbiwgdGlsZVNwYWNpbmcsIGdpZCkge1xyXG4gICAgICAgIGNvbnN0IHRpbGVzZXRJbWFnZSA9IG9yaWdpbmFsVGlsZW1hcEFkZFRpbGVzZXRJbWFnZS5jYWxsKHRoaXMsIHRpbGVzZXQsIGtleSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0LCB0aWxlTWFyZ2luLCB0aWxlU3BhY2luZywgZ2lkKTtcclxuICAgICAgICB0aWxlc2V0SW1hZ2UucGx1cyA9IG5ldyBUaWxlc2V0UGx1cyh0aWxlc2V0SW1hZ2UpO1xyXG4gICAgICAgIHJldHVybiB0aWxlc2V0SW1hZ2U7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IG9yaWdpbmFsU3ByaXRlRmFjdG9yeSA9IFBoYXNlci5HYW1lT2JqZWN0RmFjdG9yeS5wcm90b3R5cGUuc3ByaXRlO1xyXG4gICAgUGhhc2VyLkdhbWVPYmplY3RGYWN0b3J5LnByb3RvdHlwZS5zcHJpdGUgPSBmdW5jdGlvbih4LCB5LCBrZXksIGZyYW1lLCBncm91cCkge1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZSA9IG9yaWdpbmFsU3ByaXRlRmFjdG9yeS5jYWxsKHRoaXMsIHgsIHksIGtleSwgZnJhbWUsIGdyb3VwKTtcclxuICAgICAgICBzcHJpdGUucGx1cyA9IG5ldyBTcHJpdGVQbHVzKHNwcml0ZSk7XHJcbiAgICAgICAgcmV0dXJuIHNwcml0ZTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24ganNvbktleShrZXkpIHtcclxuICAgICAgICByZXR1cm4ga2V5ICsgXCItVGlsZW1hcFBsdXNcIjtcclxuICAgIH1cclxufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/*!*************************************!*\
  !*** ./tilemap-plus/TilemapPlus.js ***!
  \*************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _Animation = __webpack_require__(/*! ./Animation */ 6);\n\nvar _Animation2 = _interopRequireDefault(_Animation);\n\nvar _Physics = __webpack_require__(/*! ./Physics */ 7);\n\nvar _Physics2 = _interopRequireDefault(_Physics);\n\nvar _Events = __webpack_require__(/*! ./events/Events */ 11);\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TilemapPlus = function TilemapPlus(tilemapJson, time, tilemap) {\n    _classCallCheck(this, TilemapPlus);\n\n    this.tilemapJson = tilemapJson;\n    this.time = time;\n    this.tilemap = tilemap;\n    this.timer = null;\n    this.tileAnimations = [];\n    this.game = time.game;\n    this.animation = new _Animation2.default(tilemapJson, time, tilemap);\n    this.events = new _Events2.default();\n    this.physics = new _Physics2.default(tilemapJson, this.events);\n    this.properties = tilemapJson.properties || {};\n};\n\nexports.default = TilemapPlus;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdGlsZW1hcC1wbHVzL1RpbGVtYXBQbHVzLmpzPzczODgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEFuaW1hdGlvbiBmcm9tIFwiLi9BbmltYXRpb25cIjtcclxuaW1wb3J0IFBoeXNpY3MgZnJvbSBcIi4vUGh5c2ljc1wiO1xyXG5pbXBvcnQgRXZlbnRzIGZyb20gXCIuL2V2ZW50cy9FdmVudHNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGVtYXBQbHVzIHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih0aWxlbWFwSnNvbiwgdGltZSwgdGlsZW1hcCkge1xyXG4gICAgICAgIHRoaXMudGlsZW1hcEpzb24gPSB0aWxlbWFwSnNvbjtcclxuICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xyXG4gICAgICAgIHRoaXMudGlsZW1hcCA9IHRpbGVtYXA7XHJcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50aWxlQW5pbWF0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZ2FtZSA9IHRpbWUuZ2FtZTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24odGlsZW1hcEpzb24sIHRpbWUsIHRpbGVtYXApO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50cygpO1xyXG4gICAgICAgIHRoaXMucGh5c2ljcyA9IG5ldyBQaHlzaWNzKHRpbGVtYXBKc29uLCB0aGlzLmV2ZW50cyk7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gdGlsZW1hcEpzb24ucHJvcGVydGllcyB8fCB7fTtcclxuICAgIH0gICAgXHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy90aWxlbWFwLXBsdXMvVGlsZW1hcFBsdXMuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/*!***********************************!*\
  !*** ./tilemap-plus/Animation.js ***!
  \***********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Animation = function () {\n    function Animation(tilemapJson, time, tilemap) {\n        _classCallCheck(this, Animation);\n\n        this.tilemapJson = tilemapJson;\n        this.time = time;\n        this.tilemap = tilemap;\n        this.timer = null;\n        this.tileAnimations = [];\n        this.game = time.game;\n    }\n\n    _createClass(Animation, [{\n        key: \"enable\",\n        value: function enable() {\n            var _this = this;\n\n            if (this.timer == null) {\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = this.tilemapJson.tilesets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var tilesetJson = _step.value;\n\n                        if (tilesetJson.tiles) {\n                            _addAnimationsFromTileset.bind(this)(tilesetJson);\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n\n                this.timer = this.time.events.loop(20, function () {\n                    return _animate.bind(_this)();\n                });\n            }\n        }\n    }, {\n        key: \"disable\",\n        value: function disable() {\n            if (this.timer != null) {\n                this.time.events.remove(this.timer);\n                this.timer = null;\n                this.tileAnimations = [];\n            }\n        }\n    }]);\n\n    return Animation;\n}();\n\nexports.default = Animation;\n\n\nfunction _addAnimationsFromTileset(tilesetJson) {\n    var tilesJson = tilesetJson.tiles;\n    if (!tilesJson) {\n        return;\n    }\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n        for (var _iterator2 = Object.keys(tilesJson)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var animatedTileId = _step2.value;\n\n            var tileJson = tilesJson[animatedTileId];\n            var animationJson = tileJson.animation;\n            if (animationJson && animationJson.length > 0) {\n                _addAnimationsFromAnimatedTile.bind(this)(tilesetJson, animatedTileId, animationJson);\n            }\n        }\n    } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n            }\n        } finally {\n            if (_didIteratorError2) {\n                throw _iteratorError2;\n            }\n        }\n    }\n}\n\nfunction _addAnimationsFromAnimatedTile(tilesetJson, animatedTileId, animationJson) {\n    var frames = animationJson.map(function (element) {\n        return { tileId: element.tileid, duration: element.duration };\n    });\n\n    if (frames.length === 0) {\n        return;\n    }\n\n    var tileset = this.tilemap.tilesets.find(function (t) {\n        return t.name === tilesetJson.name;\n    });\n\n    var tileAnimation = {\n        frames: frames,\n        tileset: tileset,\n        tileLocations: _getTileLocations.bind(this)(tileset.firstgid + parseInt(animatedTileId)),\n        currentFrame: 0,\n        currentDuration: 0\n    };\n\n    this.tileAnimations.push(tileAnimation);\n}\n\nfunction _animate() {\n    var deltaTime = this.time.elapsedMS;\n\n    var dirty = false;\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n        for (var _iterator3 = this.tileAnimations[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var tileAnimation = _step3.value;\n\n            var frames = tileAnimation.frames;\n            var tileset = tileAnimation.tileset;\n            var tileLocations = tileAnimation.tileLocations;\n            var currentFrame = tileAnimation.currentFrame;\n            var frameDuration = frames[currentFrame].duration;\n            tileAnimation.currentDuration += deltaTime;\n            if (tileAnimation.currentDuration > frameDuration) {\n                tileAnimation.currentDuration -= frameDuration;\n                tileAnimation.currentFrame = (currentFrame + 1) % frames.length;\n\n                var newFrameIndex = tileset.firstgid + frames[tileAnimation.currentFrame].tileId;\n                var _iteratorNormalCompletion5 = true;\n                var _didIteratorError5 = false;\n                var _iteratorError5 = undefined;\n\n                try {\n                    for (var _iterator5 = tileLocations[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                        var tileLocation = _step5.value;\n\n                        var tile = this.tilemap.getTile(tileLocation.x, tileLocation.y, tileLocation.layer, true);\n                        tile.index = newFrameIndex;\n                    }\n                } catch (err) {\n                    _didIteratorError5 = true;\n                    _iteratorError5 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                            _iterator5.return();\n                        }\n                    } finally {\n                        if (_didIteratorError5) {\n                            throw _iteratorError5;\n                        }\n                    }\n                }\n\n                dirty = true;\n            }\n        }\n    } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                _iterator3.return();\n            }\n        } finally {\n            if (_didIteratorError3) {\n                throw _iteratorError3;\n            }\n        }\n    }\n\n    if (dirty) {\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n            for (var _iterator4 = this.tilemap.layers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                var layer = _step4.value;\n\n                layer.dirty = true;\n            }\n        } catch (err) {\n            _didIteratorError4 = true;\n            _iteratorError4 = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                    _iterator4.return();\n                }\n            } finally {\n                if (_didIteratorError4) {\n                    throw _iteratorError4;\n                }\n            }\n        }\n    }\n}\n\nfunction _getTileLocations(animatedTileId) {\n    var tileLocations = [];\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n        for (var _iterator6 = this.tilemapJson.layers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var layerJson = _step6.value;\n\n            if (layerJson.type !== \"tilelayer\") {\n                continue;\n            }\n            var data = layerJson.data;\n            var width = layerJson.width;\n            var height = layerJson.height;\n            for (var y = 0; y < height; y++) {\n                for (var x = 0; x < width; x++) {\n                    if (data[y * width + x] === animatedTileId) {\n                        tileLocations.push({ x: x, y: y, layer: layerJson.name });\n                    }\n                }\n            }\n        }\n    } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                _iterator6.return();\n            }\n        } finally {\n            if (_didIteratorError6) {\n                throw _iteratorError6;\n            }\n        }\n    }\n\n    return tileLocations;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdGlsZW1hcC1wbHVzL0FuaW1hdGlvbi5qcz8zNjc3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0aWxlbWFwSnNvbiwgdGltZSwgdGlsZW1hcCkge1xyXG4gICAgICAgIHRoaXMudGlsZW1hcEpzb24gPSB0aWxlbWFwSnNvbjtcclxuICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xyXG4gICAgICAgIHRoaXMudGlsZW1hcCA9IHRpbGVtYXA7XHJcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50aWxlQW5pbWF0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZ2FtZSA9IHRpbWUuZ2FtZTtcclxuICAgIH1cclxuXHJcbiAgICBlbmFibGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGltZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRpbGVzZXRKc29uIG9mIHRoaXMudGlsZW1hcEpzb24udGlsZXNldHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aWxlc2V0SnNvbi50aWxlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIF9hZGRBbmltYXRpb25zRnJvbVRpbGVzZXQuYmluZCh0aGlzKSh0aWxlc2V0SnNvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSB0aGlzLnRpbWUuZXZlbnRzLmxvb3AoMjAsICgpID0+IF9hbmltYXRlLmJpbmQodGhpcykoKSk7XHJcbiAgICAgICAgfSAgIFxyXG4gICAgfVxyXG5cclxuICAgIGRpc2FibGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGltZXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWUuZXZlbnRzLnJlbW92ZSh0aGlzLnRpbWVyKTtcclxuICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMudGlsZUFuaW1hdGlvbnMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBfYWRkQW5pbWF0aW9uc0Zyb21UaWxlc2V0KHRpbGVzZXRKc29uKSB7XHJcbiAgICBjb25zdCB0aWxlc0pzb24gPSB0aWxlc2V0SnNvbi50aWxlcztcclxuICAgIGlmICghdGlsZXNKc29uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBhbmltYXRlZFRpbGVJZCBvZiBPYmplY3Qua2V5cyh0aWxlc0pzb24pKSB7XHJcbiAgICAgICAgY29uc3QgdGlsZUpzb24gPSB0aWxlc0pzb25bYW5pbWF0ZWRUaWxlSWRdO1xyXG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbkpzb24gPSB0aWxlSnNvbi5hbmltYXRpb247XHJcbiAgICAgICAgaWYgKGFuaW1hdGlvbkpzb24gJiYgYW5pbWF0aW9uSnNvbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIF9hZGRBbmltYXRpb25zRnJvbUFuaW1hdGVkVGlsZS5iaW5kKHRoaXMpKHRpbGVzZXRKc29uLCBhbmltYXRlZFRpbGVJZCwgYW5pbWF0aW9uSnNvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfYWRkQW5pbWF0aW9uc0Zyb21BbmltYXRlZFRpbGUodGlsZXNldEpzb24sIGFuaW1hdGVkVGlsZUlkLCBhbmltYXRpb25Kc29uKSB7XHJcbiAgICBjb25zdCBmcmFtZXMgPSBhbmltYXRpb25Kc29uLm1hcChlbGVtZW50ID0+ICh7IHRpbGVJZDogZWxlbWVudC50aWxlaWQsIGR1cmF0aW9uOiBlbGVtZW50LmR1cmF0aW9ufSkpO1xyXG5cclxuICAgIGlmIChmcmFtZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCB0aWxlc2V0ID0gdGhpcy50aWxlbWFwLnRpbGVzZXRzLmZpbmQodCA9PiB0Lm5hbWUgPT09IHRpbGVzZXRKc29uLm5hbWUpO1xyXG4gICAgXHJcbiAgICBjb25zdCB0aWxlQW5pbWF0aW9uID0ge1xyXG4gICAgICAgIGZyYW1lcyxcclxuICAgICAgICB0aWxlc2V0LFxyXG4gICAgICAgIHRpbGVMb2NhdGlvbnM6IF9nZXRUaWxlTG9jYXRpb25zLmJpbmQodGhpcykodGlsZXNldC5maXJzdGdpZCArIHBhcnNlSW50KGFuaW1hdGVkVGlsZUlkKSksXHJcbiAgICAgICAgY3VycmVudEZyYW1lOiAwLFxyXG4gICAgICAgIGN1cnJlbnREdXJhdGlvbjogMFxyXG4gICAgfTsgICAgICAgIFxyXG5cclxuICAgIHRoaXMudGlsZUFuaW1hdGlvbnMucHVzaCh0aWxlQW5pbWF0aW9uKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX2FuaW1hdGUoKSB7XHJcbiAgICBjb25zdCBkZWx0YVRpbWUgPSB0aGlzLnRpbWUuZWxhcHNlZE1TO1xyXG5cclxuICAgIGxldCBkaXJ0eSA9IGZhbHNlO1xyXG4gICAgZm9yIChjb25zdCB0aWxlQW5pbWF0aW9uIG9mIHRoaXMudGlsZUFuaW1hdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBmcmFtZXMgPSB0aWxlQW5pbWF0aW9uLmZyYW1lcztcclxuICAgICAgICBjb25zdCB0aWxlc2V0ID0gdGlsZUFuaW1hdGlvbi50aWxlc2V0O1xyXG4gICAgICAgIGNvbnN0IHRpbGVMb2NhdGlvbnMgPSB0aWxlQW5pbWF0aW9uLnRpbGVMb2NhdGlvbnM7XHJcbiAgICAgICAgY29uc3QgY3VycmVudEZyYW1lID0gdGlsZUFuaW1hdGlvbi5jdXJyZW50RnJhbWU7XHJcbiAgICAgICAgY29uc3QgZnJhbWVEdXJhdGlvbiA9IGZyYW1lc1tjdXJyZW50RnJhbWVdLmR1cmF0aW9uO1xyXG4gICAgICAgIHRpbGVBbmltYXRpb24uY3VycmVudER1cmF0aW9uICs9IGRlbHRhVGltZTtcclxuICAgICAgICBpZiAodGlsZUFuaW1hdGlvbi5jdXJyZW50RHVyYXRpb24gPiBmcmFtZUR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRpbGVBbmltYXRpb24uY3VycmVudER1cmF0aW9uIC09IGZyYW1lRHVyYXRpb247XHJcbiAgICAgICAgICAgIHRpbGVBbmltYXRpb24uY3VycmVudEZyYW1lID0gKGN1cnJlbnRGcmFtZSArIDEpICUgZnJhbWVzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0ZyYW1lSW5kZXggPSB0aWxlc2V0LmZpcnN0Z2lkICsgZnJhbWVzW3RpbGVBbmltYXRpb24uY3VycmVudEZyYW1lXS50aWxlSWQ7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGlsZUxvY2F0aW9uIG9mIHRpbGVMb2NhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbGUgPSB0aGlzLnRpbGVtYXAuZ2V0VGlsZSh0aWxlTG9jYXRpb24ueCwgdGlsZUxvY2F0aW9uLnksIHRpbGVMb2NhdGlvbi5sYXllciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aWxlLmluZGV4ID0gbmV3RnJhbWVJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChkaXJ0eSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy50aWxlbWFwLmxheWVycykge1xyXG4gICAgICAgICAgICBsYXllci5kaXJ0eSA9IHRydWU7ICAgICAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gX2dldFRpbGVMb2NhdGlvbnMoYW5pbWF0ZWRUaWxlSWQpIHtcclxuICAgIGNvbnN0IHRpbGVMb2NhdGlvbnMgPSBbXTtcclxuICAgIGZvciAoY29uc3QgbGF5ZXJKc29uIG9mIHRoaXMudGlsZW1hcEpzb24ubGF5ZXJzKSB7XHJcbiAgICAgICAgaWYgKGxheWVySnNvbi50eXBlICE9PSBcInRpbGVsYXllclwiKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlOyAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhID0gbGF5ZXJKc29uLmRhdGE7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBsYXllckpzb24ud2lkdGg7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbGF5ZXJKc29uLmhlaWdodDtcclxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbeSAqIHdpZHRoICsgeF0gPT09IGFuaW1hdGVkVGlsZUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZUxvY2F0aW9ucy5wdXNoKHt4LCB5LCBsYXllcjogbGF5ZXJKc29uLm5hbWV9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aWxlTG9jYXRpb25zO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdGlsZW1hcC1wbHVzL0FuaW1hdGlvbi5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBNUJBO0FBQ0E7QUFDQTtBQThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUtBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBSUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFLQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFSQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUF0QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBdUJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFIQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWdCQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/*!*********************************!*\
  !*** ./tilemap-plus/Physics.js ***!
  \*********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Vector = __webpack_require__(/*! ./geometry/Vector */ 0);\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nvar _ConvexPolygon = __webpack_require__(/*! ./geometry/ConvexPolygon */ 2);\n\nvar _ConvexPolygon2 = _interopRequireDefault(_ConvexPolygon);\n\nvar _Range = __webpack_require__(/*! ./geometry/Range */ 3);\n\nvar _Range2 = _interopRequireDefault(_Range);\n\nvar _AABB = __webpack_require__(/*! ./geometry/AABB */ 1);\n\nvar _AABB2 = _interopRequireDefault(_AABB);\n\nvar _ShapeLayer = __webpack_require__(/*! ./geometry/ShapeLayer */ 9);\n\nvar _ShapeLayer2 = _interopRequireDefault(_ShapeLayer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Physics = function () {\n    function Physics(tilemapJson, events) {\n        _classCallCheck(this, Physics);\n\n        this.tilemapJson = tilemapJson;\n        this.events = events;\n    }\n\n    _createClass(Physics, [{\n        key: \"enableObjectLayer\",\n        value: function enableObjectLayer(objectLayerName) {\n            var objectLayerJson = this.tilemapJson.layers.find(function (layer) {\n                return layer.type === \"objectgroup\" && layer.name === objectLayerName;\n            });\n            if (!objectLayerJson) {\n                throw new Error(\"No object layer found with name \\\"\" + objectLayerName + \"\\\"\");\n            }\n\n            this.shapeLayer = new _ShapeLayer2.default(objectLayerJson);\n        }\n    }, {\n        key: \"collideWith\",\n        value: function collideWith(sprite) {\n            if (!this.shapeLayer) {\n                return;\n            }\n\n            var body = sprite.body;\n            var gravity = sprite.game.physics.arcade.gravity;\n            var gravityVector = new _Vector2.default(gravity.x, gravity.y);\n            var gravityNormal = gravityVector.normalized();\n            var velocity = new _Vector2.default(body.velocity.x, body.velocity.y);\n\n            if (!body.contactNormal) {\n                body.contactNormal = new _Vector2.default();\n            }\n            body.contactNormal.x = body.contactNormal.y = 0;\n            var totalPenetration = new _Vector2.default();\n            var bounce = 0;\n\n            var bodyAABB = new _AABB2.default(body.x - 1, body.y - 1, body.x + body.width + 1, body.y + body.height + 1);\n            var candidateShapes = this.shapeLayer.quadTree.candidateShapes(bodyAABB);\n            var collidedShapes = [];\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = candidateShapes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var shape = _step.value;\n\n                    var collision = shape.collideWidth(body);\n                    if (!collision) {\n                        continue;\n                    }\n\n                    var penetration = collision.penetration;\n                    var _normal = collision.normal;\n\n                    // if moving away, no resitution to compute\n                    var _speedNormal = velocity.dot(_normal);\n                    if (_speedNormal >= 0) {\n                        continue;\n                    }\n\n                    // accumulate normal from multiple shapes\n                    body.contactNormal = body.contactNormal.plus(_normal);\n\n                    // accumulate penetration\n                    totalPenetration = totalPenetration.plus(penetration);\n\n                    // accumulate bounce\n                    var properties = shape.properties;\n                    var shapeBounce = properties.bounce;\n                    if (shapeBounce) {\n                        bounce += shapeBounce;\n                    }\n\n                    // track collided shapes for event notification\n                    collidedShapes.push(shape);\n                }\n\n                // resolve penetration\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            body.x -= totalPenetration.x;\n            body.y -= totalPenetration.y;\n\n            body.contactNormal = body.contactNormal.normalized();\n            var normal = body.contactNormal;\n\n            var speedNormal = velocity.dot(normal);\n\n            // decompose old velocity into normal and tangent components\n            var velocityNormal = normal.scale(speedNormal);\n            var velocityTangent = velocity.minus(velocityNormal);\n\n            // compute restitution on normal component\n            var newVelocityNormal = void 0;\n            newVelocityNormal = velocityNormal.scale(-bounce);\n\n            // todo: compute friction on tangent component                \n            var newVelocityTangent = velocityTangent;\n\n            var newVelocity = newVelocityNormal.plus(newVelocityTangent);\n\n            body.velocity.x = newVelocity.x;\n            body.velocity.y = newVelocity.y;\n\n            // notify event system\n            this.events.collisions.notify(sprite, collidedShapes, velocity, newVelocity, normal);\n        }\n    }]);\n\n    return Physics;\n}();\n\nexports.default = Physics;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdGlsZW1hcC1wbHVzL1BoeXNpY3MuanM/NDk5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVmVjdG9yIGZyb20gXCIuL2dlb21ldHJ5L1ZlY3RvclwiO1xyXG5pbXBvcnQgQ29udmV4UG9seWdvbiBmcm9tIFwiLi9nZW9tZXRyeS9Db252ZXhQb2x5Z29uXCI7XHJcbmltcG9ydCBSYW5nZSBmcm9tIFwiLi9nZW9tZXRyeS9SYW5nZVwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi9nZW9tZXRyeS9BQUJCXCI7XHJcbmltcG9ydCBTaGFwZUxheWVyIGZyb20gXCIuL2dlb21ldHJ5L1NoYXBlTGF5ZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBoeXNpY3Mge1xyXG4gICAgY29uc3RydWN0b3IodGlsZW1hcEpzb24sIGV2ZW50cykge1xyXG4gICAgICAgIHRoaXMudGlsZW1hcEpzb24gPSB0aWxlbWFwSnNvbjtcclxuICAgICAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcclxuICAgIH1cclxuXHJcbiAgICBlbmFibGVPYmplY3RMYXllcihvYmplY3RMYXllck5hbWUpIHtcclxuICAgICAgICBjb25zdCBvYmplY3RMYXllckpzb24gPSB0aGlzLnRpbGVtYXBKc29uLmxheWVycy5maW5kKGxheWVyID0+IGxheWVyLnR5cGUgPT09IFwib2JqZWN0Z3JvdXBcIiAmJiBsYXllci5uYW1lID09PSBvYmplY3RMYXllck5hbWUpO1xyXG4gICAgICAgIGlmICghb2JqZWN0TGF5ZXJKc29uKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gb2JqZWN0IGxheWVyIGZvdW5kIHdpdGggbmFtZSBcIiR7b2JqZWN0TGF5ZXJOYW1lfVwiYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNoYXBlTGF5ZXIgPSBuZXcgU2hhcGVMYXllcihvYmplY3RMYXllckpzb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbGxpZGVXaXRoKHNwcml0ZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5zaGFwZUxheWVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGJvZHkgPSBzcHJpdGUuYm9keTtcclxuICAgICAgICBjb25zdCBncmF2aXR5ID0gc3ByaXRlLmdhbWUucGh5c2ljcy5hcmNhZGUuZ3Jhdml0eTtcclxuICAgICAgICBjb25zdCBncmF2aXR5VmVjdG9yID0gbmV3IFZlY3RvcihncmF2aXR5LngsIGdyYXZpdHkueSk7XHJcbiAgICAgICAgY29uc3QgZ3Jhdml0eU5vcm1hbCA9IGdyYXZpdHlWZWN0b3Iubm9ybWFsaXplZCgpO1xyXG4gICAgICAgIGNvbnN0IHZlbG9jaXR5ID0gbmV3IFZlY3Rvcihib2R5LnZlbG9jaXR5LngsIGJvZHkudmVsb2NpdHkueSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKCFib2R5LmNvbnRhY3ROb3JtYWwpIHtcclxuICAgICAgICAgICAgYm9keS5jb250YWN0Tm9ybWFsID0gbmV3IFZlY3RvcigpOyAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBib2R5LmNvbnRhY3ROb3JtYWwueCA9IGJvZHkuY29udGFjdE5vcm1hbC55ID0gMDtcclxuICAgICAgICBsZXQgdG90YWxQZW5ldHJhdGlvbiA9IG5ldyBWZWN0b3IoKTtcclxuICAgICAgICBsZXQgYm91bmNlID0gMDtcclxuXHJcbiAgICAgICAgY29uc3QgYm9keUFBQkIgPSBuZXcgQUFCQihib2R5LnggLSAxLCBib2R5LnkgLSAxLCBib2R5LnggKyBib2R5LndpZHRoICsgMSwgYm9keS55ICsgYm9keS5oZWlnaHQgKyAxKTtcclxuICAgICAgICBjb25zdCBjYW5kaWRhdGVTaGFwZXMgPSB0aGlzLnNoYXBlTGF5ZXIucXVhZFRyZWUuY2FuZGlkYXRlU2hhcGVzKGJvZHlBQUJCKTtcclxuICAgICAgICBjb25zdCBjb2xsaWRlZFNoYXBlcyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2hhcGUgb2YgY2FuZGlkYXRlU2hhcGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpc2lvbiA9IHNoYXBlLmNvbGxpZGVXaWR0aChib2R5KTtcclxuICAgICAgICAgICAgaWYgKCFjb2xsaXNpb24pIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwZW5ldHJhdGlvbiA9IGNvbGxpc2lvbi5wZW5ldHJhdGlvbjtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsID0gY29sbGlzaW9uLm5vcm1hbDtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIG1vdmluZyBhd2F5LCBubyByZXNpdHV0aW9uIHRvIGNvbXB1dGVcclxuICAgICAgICAgICAgY29uc3Qgc3BlZWROb3JtYWwgPSB2ZWxvY2l0eS5kb3Qobm9ybWFsKTtcclxuICAgICAgICAgICAgaWYgKHNwZWVkTm9ybWFsID49IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBhY2N1bXVsYXRlIG5vcm1hbCBmcm9tIG11bHRpcGxlIHNoYXBlc1xyXG4gICAgICAgICAgICBib2R5LmNvbnRhY3ROb3JtYWwgPSBib2R5LmNvbnRhY3ROb3JtYWwucGx1cyhub3JtYWwpO1xyXG5cclxuICAgICAgICAgICAgLy8gYWNjdW11bGF0ZSBwZW5ldHJhdGlvblxyXG4gICAgICAgICAgICB0b3RhbFBlbmV0cmF0aW9uID0gdG90YWxQZW5ldHJhdGlvbi5wbHVzKHBlbmV0cmF0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGFjY3VtdWxhdGUgYm91bmNlXHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBzaGFwZS5wcm9wZXJ0aWVzO1xyXG4gICAgICAgICAgICBjb25zdCBzaGFwZUJvdW5jZSA9IHByb3BlcnRpZXMuYm91bmNlO1xyXG4gICAgICAgICAgICBpZiAoc2hhcGVCb3VuY2UpIHtcclxuICAgICAgICAgICAgICAgIGJvdW5jZSArPSBzaGFwZUJvdW5jZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gdHJhY2sgY29sbGlkZWQgc2hhcGVzIGZvciBldmVudCBub3RpZmljYXRpb25cclxuICAgICAgICAgICAgY29sbGlkZWRTaGFwZXMucHVzaChzaGFwZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXNvbHZlIHBlbmV0cmF0aW9uXHJcbiAgICAgICAgYm9keS54IC09IHRvdGFsUGVuZXRyYXRpb24ueDtcclxuICAgICAgICBib2R5LnkgLT0gdG90YWxQZW5ldHJhdGlvbi55O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgYm9keS5jb250YWN0Tm9ybWFsID0gYm9keS5jb250YWN0Tm9ybWFsLm5vcm1hbGl6ZWQoKTtcclxuICAgICAgICBjb25zdCBub3JtYWwgPSBib2R5LmNvbnRhY3ROb3JtYWw7XHJcblxyXG4gICAgICAgIGNvbnN0IHNwZWVkTm9ybWFsID0gdmVsb2NpdHkuZG90KG5vcm1hbCk7ICAgICAgICBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgLy8gZGVjb21wb3NlIG9sZCB2ZWxvY2l0eSBpbnRvIG5vcm1hbCBhbmQgdGFuZ2VudCBjb21wb25lbnRzXHJcbiAgICAgICAgY29uc3QgdmVsb2NpdHlOb3JtYWwgPSBub3JtYWwuc2NhbGUoc3BlZWROb3JtYWwpO1xyXG4gICAgICAgIGNvbnN0IHZlbG9jaXR5VGFuZ2VudCA9IHZlbG9jaXR5Lm1pbnVzKHZlbG9jaXR5Tm9ybWFsKTtcclxuXHJcbiAgICAgICAgLy8gY29tcHV0ZSByZXN0aXR1dGlvbiBvbiBub3JtYWwgY29tcG9uZW50XHJcbiAgICAgICAgbGV0IG5ld1ZlbG9jaXR5Tm9ybWFsO1xyXG4gICAgICAgIG5ld1ZlbG9jaXR5Tm9ybWFsID0gdmVsb2NpdHlOb3JtYWwuc2NhbGUoLWJvdW5jZSk7XHJcblxyXG4gICAgICAgIC8vIHRvZG86IGNvbXB1dGUgZnJpY3Rpb24gb24gdGFuZ2VudCBjb21wb25lbnQgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgY29uc3QgbmV3VmVsb2NpdHlUYW5nZW50ID0gdmVsb2NpdHlUYW5nZW50O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IG5ld1ZlbG9jaXR5ID0gbmV3VmVsb2NpdHlOb3JtYWwucGx1cyhuZXdWZWxvY2l0eVRhbmdlbnQpO1xyXG5cclxuICAgICAgICBib2R5LnZlbG9jaXR5LnggPSBuZXdWZWxvY2l0eS54O1xyXG4gICAgICAgIGJvZHkudmVsb2NpdHkueSA9IG5ld1ZlbG9jaXR5Lnk7XHJcblxyXG4gICAgICAgIC8vIG5vdGlmeSBldmVudCBzeXN0ZW1cclxuICAgICAgICB0aGlzLmV2ZW50cy5jb2xsaXNpb25zLm5vdGlmeShzcHJpdGUsIGNvbGxpZGVkU2hhcGVzLCB2ZWxvY2l0eSwgbmV3VmVsb2NpdHksIG5vcm1hbCk7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RpbGVtYXAtcGx1cy9QaHlzaWNzLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFxQkE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUEvRkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/*!************************************************!*\
  !*** ../node_modules/poly-decomp/src/index.js ***!
  \************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = {\n    decomp: polygonDecomp,\n    quickDecomp: polygonQuickDecomp,\n    isSimple: polygonIsSimple,\n    removeCollinearPoints: polygonRemoveCollinearPoints,\n    makeCCW: polygonMakeCCW\n};\n\n/**\n * Compute the intersection between two lines.\n * @static\n * @method lineInt\n * @param  {Array}  l1          Line vector 1\n * @param  {Array}  l2          Line vector 2\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\n * @return {Array}              The intersection point.\n */\nfunction lineInt(l1,l2,precision){\n    precision = precision || 0;\n    var i = [0,0]; // point\n    var a1, b1, c1, a2, b2, c2, det; // scalars\n    a1 = l1[1][1] - l1[0][1];\n    b1 = l1[0][0] - l1[1][0];\n    c1 = a1 * l1[0][0] + b1 * l1[0][1];\n    a2 = l2[1][1] - l2[0][1];\n    b2 = l2[0][0] - l2[1][0];\n    c2 = a2 * l2[0][0] + b2 * l2[0][1];\n    det = a1 * b2 - a2*b1;\n    if (!scalar_eq(det, 0, precision)) { // lines are not parallel\n        i[0] = (b2 * c1 - b1 * c2) / det;\n        i[1] = (a1 * c2 - a2 * c1) / det;\n    }\n    return i;\n}\n\n/**\n * Checks if two line segments intersects.\n * @method segmentsIntersect\n * @param {Array} p1 The start vertex of the first line segment.\n * @param {Array} p2 The end vertex of the first line segment.\n * @param {Array} q1 The start vertex of the second line segment.\n * @param {Array} q2 The end vertex of the second line segment.\n * @return {Boolean} True if the two line segments intersect\n */\nfunction lineSegmentsIntersect(p1, p2, q1, q2){\n\tvar dx = p2[0] - p1[0];\n\tvar dy = p2[1] - p1[1];\n\tvar da = q2[0] - q1[0];\n\tvar db = q2[1] - q1[1];\n\n\t// segments are parallel\n\tif((da*dy - db*dx) === 0){\n\t\treturn false;\n\t}\n\n\tvar s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\n\tvar t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\n\n\treturn (s>=0 && s<=1 && t>=0 && t<=1);\n}\n\n/**\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\n * @static\n * @method area\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @return {Number}\n */\nfunction triangleArea(a,b,c){\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));\n}\n\nfunction isLeft(a,b,c){\n    return triangleArea(a,b,c) > 0;\n}\n\nfunction isLeftOn(a,b,c) {\n    return triangleArea(a, b, c) >= 0;\n}\n\nfunction isRight(a,b,c) {\n    return triangleArea(a, b, c) < 0;\n}\n\nfunction isRightOn(a,b,c) {\n    return triangleArea(a, b, c) <= 0;\n}\n\nvar tmpPoint1 = [],\n    tmpPoint2 = [];\n\n/**\n * Check if three points are collinear\n * @method collinear\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\n * @return {Boolean}\n */\nfunction collinear(a,b,c,thresholdAngle) {\n    if(!thresholdAngle){\n        return triangleArea(a, b, c) === 0;\n    } else {\n        var ab = tmpPoint1,\n            bc = tmpPoint2;\n\n        ab[0] = b[0]-a[0];\n        ab[1] = b[1]-a[1];\n        bc[0] = c[0]-b[0];\n        bc[1] = c[1]-b[1];\n\n        var dot = ab[0]*bc[0] + ab[1]*bc[1],\n            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),\n            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),\n            angle = Math.acos(dot/(magA*magB));\n        return angle < thresholdAngle;\n    }\n}\n\nfunction sqdist(a,b){\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    return dx * dx + dy * dy;\n}\n\n/**\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\n * @method at\n * @param  {Number} i\n * @return {Array}\n */\nfunction polygonAt(polygon, i){\n    var s = polygon.length;\n    return polygon[i < 0 ? i % s + s : i % s];\n}\n\n/**\n * Clear the polygon data\n * @method clear\n * @return {Array}\n */\nfunction polygonClear(polygon){\n    polygon.length = 0;\n}\n\n/**\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\n * @method append\n * @param {Polygon} poly The polygon to get points from.\n * @param {Number}  from The vertex index in \"poly\".\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\n * @return {Array}\n */\nfunction polygonAppend(polygon, poly, from, to){\n    for(var i=from; i<to; i++){\n        polygon.push(poly[i]);\n    }\n}\n\n/**\n * Make sure that the polygon vertices are ordered counter-clockwise.\n * @method makeCCW\n */\nfunction polygonMakeCCW(polygon){\n    var br = 0,\n        v = polygon;\n\n    // find bottom right point\n    for (var i = 1; i < polygon.length; ++i) {\n        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {\n            br = i;\n        }\n    }\n\n    // reverse poly if clockwise\n    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\n        polygonReverse(polygon);\n    }\n}\n\n/**\n * Reverse the vertices in the polygon\n * @method reverse\n */\nfunction polygonReverse(polygon){\n    var tmp = [];\n    var N = polygon.length;\n    for(var i=0; i!==N; i++){\n        tmp.push(polygon.pop());\n    }\n    for(var i=0; i!==N; i++){\n\t\tpolygon[i] = tmp[i];\n    }\n}\n\n/**\n * Check if a point in the polygon is a reflex point\n * @method isReflex\n * @param  {Number}  i\n * @return {Boolean}\n */\nfunction polygonIsReflex(polygon, i){\n    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\n}\n\nvar tmpLine1=[],\n    tmpLine2=[];\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee(polygon, a,b) {\n    var p, dist, l1=tmpLine1, l2=tmpLine2;\n\n    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\n        return false;\n    }\n    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\n    for (var i = 0; i !== polygon.length; ++i) { // for each edge\n        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges\n            continue;\n        }\n        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge\n            l1[0] = polygonAt(polygon, a);\n            l1[1] = polygonAt(polygon, b);\n            l2[0] = polygonAt(polygon, i);\n            l2[1] = polygonAt(polygon, i + 1);\n            p = lineInt(l1,l2);\n            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n/**\n * Copy the polygon from vertex i to vertex j.\n * @method copy\n * @param  {Number} i\n * @param  {Number} j\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\n * @return {Polygon}                The resulting copy.\n */\nfunction polygonCopy(polygon, i,j,targetPoly){\n    var p = targetPoly || [];\n    polygonClear(p);\n    if (i < j) {\n        // Insert all vertices from i to j\n        for(var k=i; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n    } else {\n\n        // Insert vertices 0 to j\n        for(var k=0; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n        // Insert vertices i to end\n        for(var k=i; k<polygon.length; k++){\n            p.push(polygon[k]);\n        }\n    }\n\n    return p;\n}\n\n/**\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\n * @method getCutEdges\n * @return {Array}\n */\nfunction polygonGetCutEdges(polygon) {\n    var min=[], tmp1=[], tmp2=[], tmpPoly = [];\n    var nDiags = Number.MAX_VALUE;\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(polygon, i)) {\n            for (var j = 0; j < polygon.length; ++j) {\n                if (polygonCanSee(polygon, i, j)) {\n                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\n                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\n\n                    for(var k=0; k<tmp2.length; k++){\n                        tmp1.push(tmp2[k]);\n                    }\n\n                    if (tmp1.length < nDiags) {\n                        min = tmp1;\n                        nDiags = tmp1.length;\n                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);\n                    }\n                }\n            }\n        }\n    }\n\n    return min;\n}\n\n/**\n * Decomposes the polygon into one or more convex sub-Polygons.\n * @method decomp\n * @return {Array} An array or Polygon objects.\n */\nfunction polygonDecomp(polygon){\n    var edges = polygonGetCutEdges(polygon);\n    if(edges.length > 0){\n        return polygonSlice(polygon, edges);\n    } else {\n        return [polygon];\n    }\n}\n\n/**\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\n * @method slice\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\n * @return {Array}\n */\nfunction polygonSlice(polygon, cutEdges){\n    if(cutEdges.length === 0){\n\t\treturn [polygon];\n    }\n    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length===2 && cutEdges[0][0] instanceof Array){\n\n        var polys = [polygon];\n\n        for(var i=0; i<cutEdges.length; i++){\n            var cutEdge = cutEdges[i];\n            // Cut all polys\n            for(var j=0; j<polys.length; j++){\n                var poly = polys[j];\n                var result = polygonSlice(poly, cutEdge);\n                if(result){\n                    // Found poly! Cut and quit\n                    polys.splice(j,1);\n                    polys.push(result[0],result[1]);\n                    break;\n                }\n            }\n        }\n\n        return polys;\n    } else {\n\n        // Was given one edge\n        var cutEdge = cutEdges;\n        var i = polygon.indexOf(cutEdge[0]);\n        var j = polygon.indexOf(cutEdge[1]);\n\n        if(i !== -1 && j !== -1){\n            return [polygonCopy(polygon, i,j),\n                    polygonCopy(polygon, j,i)];\n        } else {\n            return false;\n        }\n    }\n}\n\n/**\n * Checks that the line segments of this polygon do not intersect each other.\n * @method isSimple\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\n * @return {Boolean}\n * @todo Should it check all segments with all others?\n */\nfunction polygonIsSimple(polygon){\n    var path = polygon, i;\n    // Check\n    for(i=0; i<path.length-1; i++){\n        for(var j=0; j<i-1; j++){\n            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){\n                return false;\n            }\n        }\n    }\n\n    // Check the segment between the last and the first point to all others\n    for(i=1; i<path.length-2; i++){\n        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction getIntersectionPoint(p1, p2, q1, q2, delta){\n\tdelta = delta || 0;\n\tvar a1 = p2[1] - p1[1];\n\tvar b1 = p1[0] - p2[0];\n\tvar c1 = (a1 * p1[0]) + (b1 * p1[1]);\n\tvar a2 = q2[1] - q1[1];\n\tvar b2 = q1[0] - q2[0];\n\tvar c2 = (a2 * q1[0]) + (b2 * q1[1]);\n\tvar det = (a1 * b2) - (a2 * b1);\n\n\tif(!scalar_eq(det,0,delta)){\n\t\treturn [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det];\n\t} else {\n\t\treturn [0,0];\n    }\n}\n\n/**\n * Quickly decompose the Polygon into convex sub-polygons.\n * @method quickDecomp\n * @param  {Array} result\n * @param  {Array} [reflexVertices]\n * @param  {Array} [steinerPoints]\n * @param  {Number} [delta]\n * @param  {Number} [maxlevel]\n * @param  {Number} [level]\n * @return {Array}\n */\nfunction polygonQuickDecomp(polygon, result,reflexVertices,steinerPoints,delta,maxlevel,level){\n    maxlevel = maxlevel || 100;\n    level = level || 0;\n    delta = delta || 25;\n    result = typeof(result)!==\"undefined\" ? result : [];\n    reflexVertices = reflexVertices || [];\n    steinerPoints = steinerPoints || [];\n\n    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points\n    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars\n    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers\n    var lowerPoly=[], upperPoly=[]; // polygons\n    var poly = polygon,\n        v = polygon;\n\n    if(v.length < 3){\n\t\treturn result;\n    }\n\n    level++;\n    if(level > maxlevel){\n        console.warn(\"quickDecomp: max level (\"+maxlevel+\") reached.\");\n        return result;\n    }\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(poly, i)) {\n            reflexVertices.push(poly[i]);\n            upperDist = lowerDist = Number.MAX_VALUE;\n\n\n            for (var j = 0; j < polygon.length; ++j) {\n                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge\n                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\n                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly\n                        d = sqdist(poly[i], p);\n                        if (d < lowerDist) { // keep only the closest intersection\n                            lowerDist = d;\n                            lowerInt = p;\n                            lowerIndex = j;\n                        }\n                    }\n                }\n                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\n                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\n                        d = sqdist(poly[i], p);\n                        if (d < upperDist) {\n                            upperDist = d;\n                            upperInt = p;\n                            upperIndex = j;\n                        }\n                    }\n                }\n            }\n\n            // if there are no vertices to connect to, choose a point in the middle\n            if (lowerIndex === (upperIndex + 1) % polygon.length) {\n                //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\n                p[0] = (lowerInt[0] + upperInt[0]) / 2;\n                p[1] = (lowerInt[1] + upperInt[1]) / 2;\n                steinerPoints.push(p);\n\n                if (i < upperIndex) {\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly, i, upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    if (lowerIndex !== 0){\n                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\n                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);\n                    }\n                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\n                        polygonAppend(lowerPoly, poly,i,poly.length);\n                    }\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly,0,upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,lowerIndex,i+1);\n                }\n            } else {\n                // connect to the closest point within the triangle\n                //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\n\n                if (lowerIndex > upperIndex) {\n                    upperIndex += polygon.length;\n                }\n                closestDist = Number.MAX_VALUE;\n\n                if(upperIndex < lowerIndex){\n                    return result;\n                }\n\n                for (var j = lowerIndex; j <= upperIndex; ++j) {\n                    if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\n                        if (d < closestDist) {\n                            closestDist = d;\n                            closestIndex = j % polygon.length;\n                        }\n                    }\n                }\n\n                if (i < closestIndex) {\n                    polygonAppend(lowerPoly, poly,i,closestIndex+1);\n                    if (closestIndex !== 0){\n                        polygonAppend(upperPoly, poly,closestIndex,v.length);\n                    }\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        polygonAppend(lowerPoly, poly,i,v.length);\n                    }\n                    polygonAppend(lowerPoly, poly,0,closestIndex+1);\n                    polygonAppend(upperPoly, poly,closestIndex,i+1);\n                }\n            }\n\n            // solve smallest poly first\n            if (lowerPoly.length < upperPoly.length) {\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            } else {\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            }\n\n            return result;\n        }\n    }\n    result.push(polygon);\n\n    return result;\n}\n\n/**\n * Remove collinear points in the polygon.\n * @method removeCollinearPoints\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\n * @return {Number}           The number of points removed\n */\nfunction polygonRemoveCollinearPoints(polygon, precision){\n    var num = 0;\n    for(var i=polygon.length-1; polygon.length>3 && i>=0; --i){\n        if(collinear(polygonAt(polygon, i-1),polygonAt(polygon, i),polygonAt(polygon, i+1),precision)){\n            // Remove the middle point\n            polygon.splice(i%polygon.length,1);\n            num++;\n        }\n    }\n    return num;\n}\n\n/**\n * Check if two scalars are equal\n * @static\n * @method eq\n * @param  {Number} a\n * @param  {Number} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction scalar_eq(a,b,precision){\n    precision = precision || 0;\n    return Math.abs(a-b) < precision;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcG9seS1kZWNvbXAvc3JjL2luZGV4LmpzP2YzNmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGVjb21wOiBwb2x5Z29uRGVjb21wLFxuICAgIHF1aWNrRGVjb21wOiBwb2x5Z29uUXVpY2tEZWNvbXAsXG4gICAgaXNTaW1wbGU6IHBvbHlnb25Jc1NpbXBsZSxcbiAgICByZW1vdmVDb2xsaW5lYXJQb2ludHM6IHBvbHlnb25SZW1vdmVDb2xsaW5lYXJQb2ludHMsXG4gICAgbWFrZUNDVzogcG9seWdvbk1ha2VDQ1dcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdHdvIGxpbmVzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBsaW5lSW50XG4gKiBAcGFyYW0gIHtBcnJheX0gIGwxICAgICAgICAgIExpbmUgdmVjdG9yIDFcbiAqIEBwYXJhbSAge0FycmF5fSAgbDIgICAgICAgICAgTGluZSB2ZWN0b3IgMlxuICogQHBhcmFtICB7TnVtYmVyfSBwcmVjaXNpb24gICBQcmVjaXNpb24gdG8gdXNlIHdoZW4gY2hlY2tpbmcgaWYgdGhlIGxpbmVzIGFyZSBwYXJhbGxlbFxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBUaGUgaW50ZXJzZWN0aW9uIHBvaW50LlxuICovXG5mdW5jdGlvbiBsaW5lSW50KGwxLGwyLHByZWNpc2lvbil7XG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDA7XG4gICAgdmFyIGkgPSBbMCwwXTsgLy8gcG9pbnRcbiAgICB2YXIgYTEsIGIxLCBjMSwgYTIsIGIyLCBjMiwgZGV0OyAvLyBzY2FsYXJzXG4gICAgYTEgPSBsMVsxXVsxXSAtIGwxWzBdWzFdO1xuICAgIGIxID0gbDFbMF1bMF0gLSBsMVsxXVswXTtcbiAgICBjMSA9IGExICogbDFbMF1bMF0gKyBiMSAqIGwxWzBdWzFdO1xuICAgIGEyID0gbDJbMV1bMV0gLSBsMlswXVsxXTtcbiAgICBiMiA9IGwyWzBdWzBdIC0gbDJbMV1bMF07XG4gICAgYzIgPSBhMiAqIGwyWzBdWzBdICsgYjIgKiBsMlswXVsxXTtcbiAgICBkZXQgPSBhMSAqIGIyIC0gYTIqYjE7XG4gICAgaWYgKCFzY2FsYXJfZXEoZGV0LCAwLCBwcmVjaXNpb24pKSB7IC8vIGxpbmVzIGFyZSBub3QgcGFyYWxsZWxcbiAgICAgICAgaVswXSA9IChiMiAqIGMxIC0gYjEgKiBjMikgLyBkZXQ7XG4gICAgICAgIGlbMV0gPSAoYTEgKiBjMiAtIGEyICogYzEpIC8gZGV0O1xuICAgIH1cbiAgICByZXR1cm4gaTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0cy5cbiAqIEBtZXRob2Qgc2VnbWVudHNJbnRlcnNlY3RcbiAqIEBwYXJhbSB7QXJyYXl9IHAxIFRoZSBzdGFydCB2ZXJ0ZXggb2YgdGhlIGZpcnN0IGxpbmUgc2VnbWVudC5cbiAqIEBwYXJhbSB7QXJyYXl9IHAyIFRoZSBlbmQgdmVydGV4IG9mIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuXG4gKiBAcGFyYW0ge0FycmF5fSBxMSBUaGUgc3RhcnQgdmVydGV4IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LlxuICogQHBhcmFtIHtBcnJheX0gcTIgVGhlIGVuZCB2ZXJ0ZXggb2YgdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSB0d28gbGluZSBzZWdtZW50cyBpbnRlcnNlY3RcbiAqL1xuZnVuY3Rpb24gbGluZVNlZ21lbnRzSW50ZXJzZWN0KHAxLCBwMiwgcTEsIHEyKXtcblx0dmFyIGR4ID0gcDJbMF0gLSBwMVswXTtcblx0dmFyIGR5ID0gcDJbMV0gLSBwMVsxXTtcblx0dmFyIGRhID0gcTJbMF0gLSBxMVswXTtcblx0dmFyIGRiID0gcTJbMV0gLSBxMVsxXTtcblxuXHQvLyBzZWdtZW50cyBhcmUgcGFyYWxsZWxcblx0aWYoKGRhKmR5IC0gZGIqZHgpID09PSAwKXtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgcyA9IChkeCAqIChxMVsxXSAtIHAxWzFdKSArIGR5ICogKHAxWzBdIC0gcTFbMF0pKSAvIChkYSAqIGR5IC0gZGIgKiBkeCk7XG5cdHZhciB0ID0gKGRhICogKHAxWzFdIC0gcTFbMV0pICsgZGIgKiAocTFbMF0gLSBwMVswXSkpIC8gKGRiICogZHggLSBkYSAqIGR5KTtcblxuXHRyZXR1cm4gKHM+PTAgJiYgczw9MSAmJiB0Pj0wICYmIHQ8PTEpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYXJlYSBvZiBhIHRyaWFuZ2xlIHNwYW5uZWQgYnkgdGhlIHRocmVlIGdpdmVuIHBvaW50cy4gTm90ZSB0aGF0IHRoZSBhcmVhIHdpbGwgYmUgbmVnYXRpdmUgaWYgdGhlIHBvaW50cyBhcmUgbm90IGdpdmVuIGluIGNvdW50ZXItY2xvY2t3aXNlIG9yZGVyLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBhcmVhXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7QXJyYXl9IGJcbiAqIEBwYXJhbSAge0FycmF5fSBjXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHRyaWFuZ2xlQXJlYShhLGIsYyl7XG4gICAgcmV0dXJuICgoKGJbMF0gLSBhWzBdKSooY1sxXSAtIGFbMV0pKS0oKGNbMF0gLSBhWzBdKSooYlsxXSAtIGFbMV0pKSk7XG59XG5cbmZ1bmN0aW9uIGlzTGVmdChhLGIsYyl7XG4gICAgcmV0dXJuIHRyaWFuZ2xlQXJlYShhLGIsYykgPiAwO1xufVxuXG5mdW5jdGlvbiBpc0xlZnRPbihhLGIsYykge1xuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPj0gMDtcbn1cblxuZnVuY3Rpb24gaXNSaWdodChhLGIsYykge1xuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPCAwO1xufVxuXG5mdW5jdGlvbiBpc1JpZ2h0T24oYSxiLGMpIHtcbiAgICByZXR1cm4gdHJpYW5nbGVBcmVhKGEsIGIsIGMpIDw9IDA7XG59XG5cbnZhciB0bXBQb2ludDEgPSBbXSxcbiAgICB0bXBQb2ludDIgPSBbXTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aHJlZSBwb2ludHMgYXJlIGNvbGxpbmVhclxuICogQG1ldGhvZCBjb2xsaW5lYXJcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHBhcmFtICB7QXJyYXl9IGNcbiAqIEBwYXJhbSAge051bWJlcn0gW3RocmVzaG9sZEFuZ2xlPTBdIFRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBjb21wYXJpbmcgdGhlIHZlY3RvcnMuIFRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0cnVlIGlmIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSByZXN1bHRpbmcgdmVjdG9ycyBpcyBsZXNzIHRoYW4gdGhpcyB2YWx1ZS4gVXNlIHplcm8gZm9yIG1heCBwcmVjaXNpb24uXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBjb2xsaW5lYXIoYSxiLGMsdGhyZXNob2xkQW5nbGUpIHtcbiAgICBpZighdGhyZXNob2xkQW5nbGUpe1xuICAgICAgICByZXR1cm4gdHJpYW5nbGVBcmVhKGEsIGIsIGMpID09PSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhYiA9IHRtcFBvaW50MSxcbiAgICAgICAgICAgIGJjID0gdG1wUG9pbnQyO1xuXG4gICAgICAgIGFiWzBdID0gYlswXS1hWzBdO1xuICAgICAgICBhYlsxXSA9IGJbMV0tYVsxXTtcbiAgICAgICAgYmNbMF0gPSBjWzBdLWJbMF07XG4gICAgICAgIGJjWzFdID0gY1sxXS1iWzFdO1xuXG4gICAgICAgIHZhciBkb3QgPSBhYlswXSpiY1swXSArIGFiWzFdKmJjWzFdLFxuICAgICAgICAgICAgbWFnQSA9IE1hdGguc3FydChhYlswXSphYlswXSArIGFiWzFdKmFiWzFdKSxcbiAgICAgICAgICAgIG1hZ0IgPSBNYXRoLnNxcnQoYmNbMF0qYmNbMF0gKyBiY1sxXSpiY1sxXSksXG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYWNvcyhkb3QvKG1hZ0EqbWFnQikpO1xuICAgICAgICByZXR1cm4gYW5nbGUgPCB0aHJlc2hvbGRBbmdsZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNxZGlzdChhLGIpe1xuICAgIHZhciBkeCA9IGJbMF0gLSBhWzBdO1xuICAgIHZhciBkeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLyoqXG4gKiBHZXQgYSB2ZXJ0ZXggYXQgcG9zaXRpb24gaS4gSXQgZG9lcyBub3QgbWF0dGVyIGlmIGkgaXMgb3V0IG9mIGJvdW5kcywgdGhpcyBmdW5jdGlvbiB3aWxsIGp1c3QgY3ljbGUuXG4gKiBAbWV0aG9kIGF0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBwb2x5Z29uQXQocG9seWdvbiwgaSl7XG4gICAgdmFyIHMgPSBwb2x5Z29uLmxlbmd0aDtcbiAgICByZXR1cm4gcG9seWdvbltpIDwgMCA/IGkgJSBzICsgcyA6IGkgJSBzXTtcbn1cblxuLyoqXG4gKiBDbGVhciB0aGUgcG9seWdvbiBkYXRhXG4gKiBAbWV0aG9kIGNsZWFyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkNsZWFyKHBvbHlnb24pe1xuICAgIHBvbHlnb24ubGVuZ3RoID0gMDtcbn1cblxuLyoqXG4gKiBBcHBlbmQgcG9pbnRzIFwiZnJvbVwiIHRvIFwidG9cIi0xIGZyb20gYW4gb3RoZXIgcG9seWdvbiBcInBvbHlcIiBvbnRvIHRoaXMgb25lLlxuICogQG1ldGhvZCBhcHBlbmRcbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seSBUaGUgcG9seWdvbiB0byBnZXQgcG9pbnRzIGZyb20uXG4gKiBAcGFyYW0ge051bWJlcn0gIGZyb20gVGhlIHZlcnRleCBpbmRleCBpbiBcInBvbHlcIi5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgdG8gVGhlIGVuZCB2ZXJ0ZXggaW5kZXggaW4gXCJwb2x5XCIuIE5vdGUgdGhhdCB0aGlzIHZlcnRleCBpcyBOT1QgaW5jbHVkZWQgd2hlbiBhcHBlbmRpbmcuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkFwcGVuZChwb2x5Z29uLCBwb2x5LCBmcm9tLCB0byl7XG4gICAgZm9yKHZhciBpPWZyb207IGk8dG87IGkrKyl7XG4gICAgICAgIHBvbHlnb24ucHVzaChwb2x5W2ldKTtcbiAgICB9XG59XG5cbi8qKlxuICogTWFrZSBzdXJlIHRoYXQgdGhlIHBvbHlnb24gdmVydGljZXMgYXJlIG9yZGVyZWQgY291bnRlci1jbG9ja3dpc2UuXG4gKiBAbWV0aG9kIG1ha2VDQ1dcbiAqL1xuZnVuY3Rpb24gcG9seWdvbk1ha2VDQ1cocG9seWdvbil7XG4gICAgdmFyIGJyID0gMCxcbiAgICAgICAgdiA9IHBvbHlnb247XG5cbiAgICAvLyBmaW5kIGJvdHRvbSByaWdodCBwb2ludFxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9seWdvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodltpXVsxXSA8IHZbYnJdWzFdIHx8ICh2W2ldWzFdID09PSB2W2JyXVsxXSAmJiB2W2ldWzBdID4gdlticl1bMF0pKSB7XG4gICAgICAgICAgICBiciA9IGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXZlcnNlIHBvbHkgaWYgY2xvY2t3aXNlXG4gICAgaWYgKCFpc0xlZnQocG9seWdvbkF0KHBvbHlnb24sIGJyIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBiciksIHBvbHlnb25BdChwb2x5Z29uLCBiciArIDEpKSkge1xuICAgICAgICBwb2x5Z29uUmV2ZXJzZShwb2x5Z29uKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV2ZXJzZSB0aGUgdmVydGljZXMgaW4gdGhlIHBvbHlnb25cbiAqIEBtZXRob2QgcmV2ZXJzZVxuICovXG5mdW5jdGlvbiBwb2x5Z29uUmV2ZXJzZShwb2x5Z29uKXtcbiAgICB2YXIgdG1wID0gW107XG4gICAgdmFyIE4gPSBwb2x5Z29uLmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHRtcC5wdXNoKHBvbHlnb24ucG9wKCkpO1xuICAgIH1cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG5cdFx0cG9seWdvbltpXSA9IHRtcFtpXTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBwb2ludCBpbiB0aGUgcG9seWdvbiBpcyBhIHJlZmxleCBwb2ludFxuICogQG1ldGhvZCBpc1JlZmxleFxuICogQHBhcmFtICB7TnVtYmVyfSAgaVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbklzUmVmbGV4KHBvbHlnb24sIGkpe1xuICAgIHJldHVybiBpc1JpZ2h0KHBvbHlnb25BdChwb2x5Z29uLCBpIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBpKSwgcG9seWdvbkF0KHBvbHlnb24sIGkgKyAxKSk7XG59XG5cbnZhciB0bXBMaW5lMT1bXSxcbiAgICB0bXBMaW5lMj1bXTtcblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmVydGljZXMgaW4gdGhlIHBvbHlnb24gY2FuIHNlZSBlYWNoIG90aGVyXG4gKiBAbWV0aG9kIGNhblNlZVxuICogQHBhcmFtICB7TnVtYmVyfSBhIFZlcnRleCBpbmRleCAxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGIgVmVydGV4IGluZGV4IDJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25DYW5TZWUocG9seWdvbiwgYSxiKSB7XG4gICAgdmFyIHAsIGRpc3QsIGwxPXRtcExpbmUxLCBsMj10bXBMaW5lMjtcblxuICAgIGlmIChpc0xlZnRPbihwb2x5Z29uQXQocG9seWdvbiwgYSArIDEpLCBwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5Z29uLCBhIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcG9seWdvbkF0KHBvbHlnb24sIGIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRpc3QgPSBzcWRpc3QocG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYikpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBwb2x5Z29uLmxlbmd0aDsgKytpKSB7IC8vIGZvciBlYWNoIGVkZ2VcbiAgICAgICAgaWYgKChpICsgMSkgJSBwb2x5Z29uLmxlbmd0aCA9PT0gYSB8fCBpID09PSBhKXsgLy8gaWdub3JlIGluY2lkZW50IGVkZ2VzXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMZWZ0T24ocG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYiksIHBvbHlnb25BdChwb2x5Z29uLCBpICsgMSkpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSwgcG9seWdvbkF0KHBvbHlnb24sIGkpKSkgeyAvLyBpZiBkaWFnIGludGVyc2VjdHMgYW4gZWRnZVxuICAgICAgICAgICAgbDFbMF0gPSBwb2x5Z29uQXQocG9seWdvbiwgYSk7XG4gICAgICAgICAgICBsMVsxXSA9IHBvbHlnb25BdChwb2x5Z29uLCBiKTtcbiAgICAgICAgICAgIGwyWzBdID0gcG9seWdvbkF0KHBvbHlnb24sIGkpO1xuICAgICAgICAgICAgbDJbMV0gPSBwb2x5Z29uQXQocG9seWdvbiwgaSArIDEpO1xuICAgICAgICAgICAgcCA9IGxpbmVJbnQobDEsbDIpO1xuICAgICAgICAgICAgaWYgKHNxZGlzdChwb2x5Z29uQXQocG9seWdvbiwgYSksIHApIDwgZGlzdCkgeyAvLyBpZiBlZGdlIGlzIGJsb2NraW5nIHZpc2liaWxpdHkgdG8gYlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvcHkgdGhlIHBvbHlnb24gZnJvbSB2ZXJ0ZXggaSB0byB2ZXJ0ZXggai5cbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEBwYXJhbSAge1BvbHlnb259IFt0YXJnZXRQb2x5XSAgIE9wdGlvbmFsIHRhcmdldCBwb2x5Z29uIHRvIHNhdmUgaW4uXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSAgICAgICAgICAgICAgICBUaGUgcmVzdWx0aW5nIGNvcHkuXG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25Db3B5KHBvbHlnb24sIGksaix0YXJnZXRQb2x5KXtcbiAgICB2YXIgcCA9IHRhcmdldFBvbHkgfHwgW107XG4gICAgcG9seWdvbkNsZWFyKHApO1xuICAgIGlmIChpIDwgaikge1xuICAgICAgICAvLyBJbnNlcnQgYWxsIHZlcnRpY2VzIGZyb20gaSB0byBqXG4gICAgICAgIGZvcih2YXIgaz1pOyBrPD1qOyBrKyspe1xuICAgICAgICAgICAgcC5wdXNoKHBvbHlnb25ba10pO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIEluc2VydCB2ZXJ0aWNlcyAwIHRvIGpcbiAgICAgICAgZm9yKHZhciBrPTA7IGs8PWo7IGsrKyl7XG4gICAgICAgICAgICBwLnB1c2gocG9seWdvbltrXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnNlcnQgdmVydGljZXMgaSB0byBlbmRcbiAgICAgICAgZm9yKHZhciBrPWk7IGs8cG9seWdvbi5sZW5ndGg7IGsrKyl7XG4gICAgICAgICAgICBwLnB1c2gocG9seWdvbltrXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbn1cblxuLyoqXG4gKiBEZWNvbXBvc2VzIHRoZSBwb2x5Z29uIGludG8gY29udmV4IHBpZWNlcy4gUmV0dXJucyBhIGxpc3Qgb2YgZWRnZXMgW1twMSxwMl0sW3AyLHAzXSwuLi5dIHRoYXQgY3V0cyB0aGUgcG9seWdvbi5cbiAqIE5vdGUgdGhhdCB0aGlzIGFsZ29yaXRobSBoYXMgY29tcGxleGl0eSBPKE5eNCkgYW5kIHdpbGwgYmUgdmVyeSBzbG93IGZvciBwb2x5Z29ucyB3aXRoIG1hbnkgdmVydGljZXMuXG4gKiBAbWV0aG9kIGdldEN1dEVkZ2VzXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkdldEN1dEVkZ2VzKHBvbHlnb24pIHtcbiAgICB2YXIgbWluPVtdLCB0bXAxPVtdLCB0bXAyPVtdLCB0bXBQb2x5ID0gW107XG4gICAgdmFyIG5EaWFncyA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb24ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHBvbHlnb25Jc1JlZmxleChwb2x5Z29uLCBpKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2x5Z29uLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvbHlnb25DYW5TZWUocG9seWdvbiwgaSwgaikpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wMSA9IHBvbHlnb25HZXRDdXRFZGdlcyhwb2x5Z29uQ29weShwb2x5Z29uLCBpLCBqLCB0bXBQb2x5KSk7XG4gICAgICAgICAgICAgICAgICAgIHRtcDIgPSBwb2x5Z29uR2V0Q3V0RWRnZXMocG9seWdvbkNvcHkocG9seWdvbiwgaiwgaSwgdG1wUG9seSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaz0wOyBrPHRtcDIubGVuZ3RoOyBrKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wMS5wdXNoKHRtcDJba10pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtcDEubGVuZ3RoIDwgbkRpYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSB0bXAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbkRpYWdzID0gdG1wMS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4ucHVzaChbcG9seWdvbkF0KHBvbHlnb24sIGkpLCBwb2x5Z29uQXQocG9seWdvbiwgaildKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtaW47XG59XG5cbi8qKlxuICogRGVjb21wb3NlcyB0aGUgcG9seWdvbiBpbnRvIG9uZSBvciBtb3JlIGNvbnZleCBzdWItUG9seWdvbnMuXG4gKiBAbWV0aG9kIGRlY29tcFxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9yIFBvbHlnb24gb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkRlY29tcChwb2x5Z29uKXtcbiAgICB2YXIgZWRnZXMgPSBwb2x5Z29uR2V0Q3V0RWRnZXMocG9seWdvbik7XG4gICAgaWYoZWRnZXMubGVuZ3RoID4gMCl7XG4gICAgICAgIHJldHVybiBwb2x5Z29uU2xpY2UocG9seWdvbiwgZWRnZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbcG9seWdvbl07XG4gICAgfVxufVxuXG4vKipcbiAqIFNsaWNlcyB0aGUgcG9seWdvbiBnaXZlbiBvbmUgb3IgbW9yZSBjdXQgZWRnZXMuIElmIGdpdmVuIG9uZSwgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0d28gcG9seWdvbnMgKGZhbHNlIG9uIGZhaWx1cmUpLiBJZiBtYW55LCBhbiBhcnJheSBvZiBwb2x5Z29ucy5cbiAqIEBtZXRob2Qgc2xpY2VcbiAqIEBwYXJhbSB7QXJyYXl9IGN1dEVkZ2VzIEEgbGlzdCBvZiBlZGdlcywgYXMgcmV0dXJuZWQgYnkgLmdldEN1dEVkZ2VzKClcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBwb2x5Z29uU2xpY2UocG9seWdvbiwgY3V0RWRnZXMpe1xuICAgIGlmKGN1dEVkZ2VzLmxlbmd0aCA9PT0gMCl7XG5cdFx0cmV0dXJuIFtwb2x5Z29uXTtcbiAgICB9XG4gICAgaWYoY3V0RWRnZXMgaW5zdGFuY2VvZiBBcnJheSAmJiBjdXRFZGdlcy5sZW5ndGggJiYgY3V0RWRnZXNbMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBjdXRFZGdlc1swXS5sZW5ndGg9PT0yICYmIGN1dEVkZ2VzWzBdWzBdIGluc3RhbmNlb2YgQXJyYXkpe1xuXG4gICAgICAgIHZhciBwb2x5cyA9IFtwb2x5Z29uXTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxjdXRFZGdlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgY3V0RWRnZSA9IGN1dEVkZ2VzW2ldO1xuICAgICAgICAgICAgLy8gQ3V0IGFsbCBwb2x5c1xuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8cG9seXMubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgICAgIHZhciBwb2x5ID0gcG9seXNbal07XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBvbHlnb25TbGljZShwb2x5LCBjdXRFZGdlKTtcbiAgICAgICAgICAgICAgICBpZihyZXN1bHQpe1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBwb2x5ISBDdXQgYW5kIHF1aXRcbiAgICAgICAgICAgICAgICAgICAgcG9seXMuc3BsaWNlKGosMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlzLnB1c2gocmVzdWx0WzBdLHJlc3VsdFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2x5cztcbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIFdhcyBnaXZlbiBvbmUgZWRnZVxuICAgICAgICB2YXIgY3V0RWRnZSA9IGN1dEVkZ2VzO1xuICAgICAgICB2YXIgaSA9IHBvbHlnb24uaW5kZXhPZihjdXRFZGdlWzBdKTtcbiAgICAgICAgdmFyIGogPSBwb2x5Z29uLmluZGV4T2YoY3V0RWRnZVsxXSk7XG5cbiAgICAgICAgaWYoaSAhPT0gLTEgJiYgaiAhPT0gLTEpe1xuICAgICAgICAgICAgcmV0dXJuIFtwb2x5Z29uQ29weShwb2x5Z29uLCBpLGopLFxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQ29weShwb2x5Z29uLCBqLGkpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgdGhhdCB0aGUgbGluZSBzZWdtZW50cyBvZiB0aGlzIHBvbHlnb24gZG8gbm90IGludGVyc2VjdCBlYWNoIG90aGVyLlxuICogQG1ldGhvZCBpc1NpbXBsZVxuICogQHBhcmFtICB7QXJyYXl9IHBhdGggQW4gYXJyYXkgb2YgdmVydGljZXMgZS5nLiBbWzAsMF0sWzAsMV0sLi4uXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEB0b2RvIFNob3VsZCBpdCBjaGVjayBhbGwgc2VnbWVudHMgd2l0aCBhbGwgb3RoZXJzP1xuICovXG5mdW5jdGlvbiBwb2x5Z29uSXNTaW1wbGUocG9seWdvbil7XG4gICAgdmFyIHBhdGggPSBwb2x5Z29uLCBpO1xuICAgIC8vIENoZWNrXG4gICAgZm9yKGk9MDsgaTxwYXRoLmxlbmd0aC0xOyBpKyspe1xuICAgICAgICBmb3IodmFyIGo9MDsgajxpLTE7IGorKyl7XG4gICAgICAgICAgICBpZihsaW5lU2VnbWVudHNJbnRlcnNlY3QocGF0aFtpXSwgcGF0aFtpKzFdLCBwYXRoW2pdLCBwYXRoW2orMV0gKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdGhlIHNlZ21lbnQgYmV0d2VlbiB0aGUgbGFzdCBhbmQgdGhlIGZpcnN0IHBvaW50IHRvIGFsbCBvdGhlcnNcbiAgICBmb3IoaT0xOyBpPHBhdGgubGVuZ3RoLTI7IGkrKyl7XG4gICAgICAgIGlmKGxpbmVTZWdtZW50c0ludGVyc2VjdChwYXRoWzBdLCBwYXRoW3BhdGgubGVuZ3RoLTFdLCBwYXRoW2ldLCBwYXRoW2krMV0gKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocDEsIHAyLCBxMSwgcTIsIGRlbHRhKXtcblx0ZGVsdGEgPSBkZWx0YSB8fCAwO1xuXHR2YXIgYTEgPSBwMlsxXSAtIHAxWzFdO1xuXHR2YXIgYjEgPSBwMVswXSAtIHAyWzBdO1xuXHR2YXIgYzEgPSAoYTEgKiBwMVswXSkgKyAoYjEgKiBwMVsxXSk7XG5cdHZhciBhMiA9IHEyWzFdIC0gcTFbMV07XG5cdHZhciBiMiA9IHExWzBdIC0gcTJbMF07XG5cdHZhciBjMiA9IChhMiAqIHExWzBdKSArIChiMiAqIHExWzFdKTtcblx0dmFyIGRldCA9IChhMSAqIGIyKSAtIChhMiAqIGIxKTtcblxuXHRpZighc2NhbGFyX2VxKGRldCwwLGRlbHRhKSl7XG5cdFx0cmV0dXJuIFsoKGIyICogYzEpIC0gKGIxICogYzIpKSAvIGRldCwgKChhMSAqIGMyKSAtIChhMiAqIGMxKSkgLyBkZXRdO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBbMCwwXTtcbiAgICB9XG59XG5cbi8qKlxuICogUXVpY2tseSBkZWNvbXBvc2UgdGhlIFBvbHlnb24gaW50byBjb252ZXggc3ViLXBvbHlnb25zLlxuICogQG1ldGhvZCBxdWlja0RlY29tcFxuICogQHBhcmFtICB7QXJyYXl9IHJlc3VsdFxuICogQHBhcmFtICB7QXJyYXl9IFtyZWZsZXhWZXJ0aWNlc11cbiAqIEBwYXJhbSAge0FycmF5fSBbc3RlaW5lclBvaW50c11cbiAqIEBwYXJhbSAge051bWJlcn0gW2RlbHRhXVxuICogQHBhcmFtICB7TnVtYmVyfSBbbWF4bGV2ZWxdXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtsZXZlbF1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBwb2x5Z29uUXVpY2tEZWNvbXAocG9seWdvbiwgcmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpe1xuICAgIG1heGxldmVsID0gbWF4bGV2ZWwgfHwgMTAwO1xuICAgIGxldmVsID0gbGV2ZWwgfHwgMDtcbiAgICBkZWx0YSA9IGRlbHRhIHx8IDI1O1xuICAgIHJlc3VsdCA9IHR5cGVvZihyZXN1bHQpIT09XCJ1bmRlZmluZWRcIiA/IHJlc3VsdCA6IFtdO1xuICAgIHJlZmxleFZlcnRpY2VzID0gcmVmbGV4VmVydGljZXMgfHwgW107XG4gICAgc3RlaW5lclBvaW50cyA9IHN0ZWluZXJQb2ludHMgfHwgW107XG5cbiAgICB2YXIgdXBwZXJJbnQ9WzAsMF0sIGxvd2VySW50PVswLDBdLCBwPVswLDBdOyAvLyBQb2ludHNcbiAgICB2YXIgdXBwZXJEaXN0PTAsIGxvd2VyRGlzdD0wLCBkPTAsIGNsb3Nlc3REaXN0PTA7IC8vIHNjYWxhcnNcbiAgICB2YXIgdXBwZXJJbmRleD0wLCBsb3dlckluZGV4PTAsIGNsb3Nlc3RJbmRleD0wOyAvLyBJbnRlZ2Vyc1xuICAgIHZhciBsb3dlclBvbHk9W10sIHVwcGVyUG9seT1bXTsgLy8gcG9seWdvbnNcbiAgICB2YXIgcG9seSA9IHBvbHlnb24sXG4gICAgICAgIHYgPSBwb2x5Z29uO1xuXG4gICAgaWYodi5sZW5ndGggPCAzKXtcblx0XHRyZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGxldmVsKys7XG4gICAgaWYobGV2ZWwgPiBtYXhsZXZlbCl7XG4gICAgICAgIGNvbnNvbGUud2FybihcInF1aWNrRGVjb21wOiBtYXggbGV2ZWwgKFwiK21heGxldmVsK1wiKSByZWFjaGVkLlwiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb24ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHBvbHlnb25Jc1JlZmxleChwb2x5LCBpKSkge1xuICAgICAgICAgICAgcmVmbGV4VmVydGljZXMucHVzaChwb2x5W2ldKTtcbiAgICAgICAgICAgIHVwcGVyRGlzdCA9IGxvd2VyRGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG5cblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2x5Z29uLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGVmdChwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5LCBpIC0gMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGogLSAxKSkpIHsgLy8gaWYgbGluZSBpbnRlcnNlY3RzIHdpdGggYW4gZWRnZVxuICAgICAgICAgICAgICAgICAgICBwID0gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaiksIHBvbHlnb25BdChwb2x5LCBqIC0gMSkpOyAvLyBmaW5kIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmlnaHQocG9seWdvbkF0KHBvbHksIGkgKyAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwKSkgeyAvLyBtYWtlIHN1cmUgaXQncyBpbnNpZGUgdGhlIHBvbHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBzcWRpc3QocG9seVtpXSwgcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IGxvd2VyRGlzdCkgeyAvLyBrZWVwIG9ubHkgdGhlIGNsb3Nlc3QgaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJEaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckludCA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJbmRleCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzTGVmdChwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqICsgMSkpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IGdldEludGVyc2VjdGlvblBvaW50KHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopLCBwb2x5Z29uQXQocG9seSwgaiArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGVmdChwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gc3FkaXN0KHBvbHlbaV0sIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCB1cHBlckRpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckRpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVySW50ID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIHZlcnRpY2VzIHRvIGNvbm5lY3QgdG8sIGNob29zZSBhIHBvaW50IGluIHRoZSBtaWRkbGVcbiAgICAgICAgICAgIGlmIChsb3dlckluZGV4ID09PSAodXBwZXJJbmRleCArIDEpICUgcG9seWdvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2FzZSAxOiBWZXJ0ZXgoXCIraStcIiksIGxvd2VySW5kZXgoXCIrbG93ZXJJbmRleCtcIiksIHVwcGVySW5kZXgoXCIrdXBwZXJJbmRleCtcIiksIHBvbHkuc2l6ZShcIitwb2x5Z29uLmxlbmd0aCtcIilcIik7XG4gICAgICAgICAgICAgICAgcFswXSA9IChsb3dlckludFswXSArIHVwcGVySW50WzBdKSAvIDI7XG4gICAgICAgICAgICAgICAgcFsxXSA9IChsb3dlckludFsxXSArIHVwcGVySW50WzFdKSAvIDI7XG4gICAgICAgICAgICAgICAgc3RlaW5lclBvaW50cy5wdXNoKHApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPCB1cHBlckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vbG93ZXJQb2x5Lmluc2VydChsb3dlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGksIHBvbHkuYmVnaW4oKSArIHVwcGVySW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZChsb3dlclBvbHksIHBvbHksIGksIHVwcGVySW5kZXgrMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VySW5kZXggIT09IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgbG93ZXJJbmRleCwgcG9seS5lbmQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSxsb3dlckluZGV4LHBvbHkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCksIHBvbHkuYmVnaW4oKSArIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksMCxpKzEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbG93ZXJQb2x5Lmluc2VydChsb3dlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGksIHBvbHkuZW5kKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZChsb3dlclBvbHksIHBvbHksaSxwb2x5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpLCBwb2x5LmJlZ2luKCkgKyB1cHBlckluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LDAsdXBwZXJJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBsb3dlckluZGV4LCBwb2x5LmJlZ2luKCkgKyBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LGxvd2VySW5kZXgsaSsxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3QgdG8gdGhlIGNsb3Nlc3QgcG9pbnQgd2l0aGluIHRoZSB0cmlhbmdsZVxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDYXNlIDI6IFZlcnRleChcIitpK1wiKSwgY2xvc2VzdEluZGV4KFwiK2Nsb3Nlc3RJbmRleCtcIiksIHBvbHkuc2l6ZShcIitwb2x5Z29uLmxlbmd0aCtcIilcXG5cIik7XG5cbiAgICAgICAgICAgICAgICBpZiAobG93ZXJJbmRleCA+IHVwcGVySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJJbmRleCArPSBwb2x5Z29uLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgICAgICAgICAgaWYodXBwZXJJbmRleCA8IGxvd2VySW5kZXgpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBsb3dlckluZGV4OyBqIDw9IHVwcGVySW5kZXg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0T24ocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBzcWRpc3QocG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBjbG9zZXN0RGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSBqICUgcG9seWdvbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA8IGNsb3Nlc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSxpLGNsb3Nlc3RJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RJbmRleCAhPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSxjbG9zZXN0SW5kZXgsdi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LDAsaSsxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSxpLHYubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSwwLGNsb3Nlc3RJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksY2xvc2VzdEluZGV4LGkrMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzb2x2ZSBzbWFsbGVzdCBwb2x5IGZpcnN0XG4gICAgICAgICAgICBpZiAobG93ZXJQb2x5Lmxlbmd0aCA8IHVwcGVyUG9seS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAobG93ZXJQb2x5LHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAodXBwZXJQb2x5LHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9seWdvblF1aWNrRGVjb21wKHVwcGVyUG9seSxyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICAgICAgcG9seWdvblF1aWNrRGVjb21wKGxvd2VyUG9seSxyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnB1c2gocG9seWdvbik7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJlbW92ZSBjb2xsaW5lYXIgcG9pbnRzIGluIHRoZSBwb2x5Z29uLlxuICogQG1ldGhvZCByZW1vdmVDb2xsaW5lYXJQb2ludHNcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl0gVGhlIHRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBkZXRlcm1pbmluZyB3aGV0aGVyIHR3byBlZGdlcyBhcmUgY29sbGluZWFyLiBVc2UgemVybyBmb3IgZmluZXN0IHByZWNpc2lvbi5cbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHJlbW92ZWRcbiAqL1xuZnVuY3Rpb24gcG9seWdvblJlbW92ZUNvbGxpbmVhclBvaW50cyhwb2x5Z29uLCBwcmVjaXNpb24pe1xuICAgIHZhciBudW0gPSAwO1xuICAgIGZvcih2YXIgaT1wb2x5Z29uLmxlbmd0aC0xOyBwb2x5Z29uLmxlbmd0aD4zICYmIGk+PTA7IC0taSl7XG4gICAgICAgIGlmKGNvbGxpbmVhcihwb2x5Z29uQXQocG9seWdvbiwgaS0xKSxwb2x5Z29uQXQocG9seWdvbiwgaSkscG9seWdvbkF0KHBvbHlnb24sIGkrMSkscHJlY2lzaW9uKSl7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG1pZGRsZSBwb2ludFxuICAgICAgICAgICAgcG9seWdvbi5zcGxpY2UoaSVwb2x5Z29uLmxlbmd0aCwxKTtcbiAgICAgICAgICAgIG51bSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHNjYWxhcnMgYXJlIGVxdWFsXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGVxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSAge051bWJlcn0gYlxuICogQHBhcmFtICB7TnVtYmVyfSBbcHJlY2lzaW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc2NhbGFyX2VxKGEsYixwcmVjaXNpb24pe1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuICAgIHJldHVybiBNYXRoLmFicyhhLWIpIDwgcHJlY2lzaW9uO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3BvbHktZGVjb21wL3NyYy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/*!*********************************************!*\
  !*** ./tilemap-plus/geometry/ShapeLayer.js ***!
  \*********************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Vector = __webpack_require__(/*! ./Vector */ 0);\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nvar _ConvexPolygon = __webpack_require__(/*! ./ConvexPolygon */ 2);\n\nvar _ConvexPolygon2 = _interopRequireDefault(_ConvexPolygon);\n\nvar _Range = __webpack_require__(/*! ./Range */ 3);\n\nvar _Range2 = _interopRequireDefault(_Range);\n\nvar _AABB = __webpack_require__(/*! ./AABB */ 1);\n\nvar _AABB2 = _interopRequireDefault(_AABB);\n\nvar _QuadTree = __webpack_require__(/*! ./QuadTree */ 10);\n\nvar _QuadTree2 = _interopRequireDefault(_QuadTree);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ShapeLayer = function () {\n    function ShapeLayer(objectLayerJson) {\n        _classCallCheck(this, ShapeLayer);\n\n        this.objectLayerJson = objectLayerJson;\n\n        this.shapes = [];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = objectLayerJson.objects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var objectJson = _step.value;\n\n                if (objectJson.polygon) {\n                    this.addPolygon(objectJson);\n                } else if (objectJson.polyline) {\n                    // ignore poly line\n                } else if (objectJson.ellipse) {\n                    // ignore ellipse\n                } else if (objectJson.gid) {\n                    // ignore tile\n                } else if (objectJson.text) {\n                    // ignore text\n                } else {\n                    // rectangle\n                    this.addRectangle(objectJson);\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        this.quadTree = new _QuadTree2.default(this.shapes, 5, 5);\n    }\n\n    _createClass(ShapeLayer, [{\n        key: \"addRectangle\",\n        value: function addRectangle(objectJson) {\n            // convert to convex polygon\n            var width = objectJson.width;\n            var height = objectJson.height;\n            var widthVector = new _Vector2.default(width, 0);\n            var heightVector = new _Vector2.default(0, height);\n            // handle box rotation\n            var angle = -objectJson.rotation * Math.PI / 180;\n            if (angle) {\n                widthVector = widthVector.rotated(angle);\n                heightVector = heightVector.rotated(angle);\n            }\n            var polygonJson = {\n                x: objectJson.x,\n                y: objectJson.y,\n                width: objectJson.width,\n                height: objectJson.height,\n                polygon: [{ x: 0, y: 0 }, widthVector, widthVector.plus(heightVector), heightVector],\n                properties: objectJson.properties || {}\n            };\n            this.addPolygon(polygonJson);\n        }\n    }, {\n        key: \"addPolygon\",\n        value: function addPolygon(objectJson) {\n            var vertices = objectJson.polygon.map(function (point) {\n                return new _Vector2.default(objectJson.x + point.x, objectJson.y + point.y);\n            });\n            var convexPolygons = _ConvexPolygon2.default.generateConvexPolygons(vertices);\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = convexPolygons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var convexPolygon = _step2.value;\n\n                    this.addConvexPolygon(convexPolygon, objectJson.properties || {});\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"addConvexPolygon\",\n        value: function addConvexPolygon(convexPolygon, properties) {\n            var aabb = convexPolygon.aabb;\n\n            var shape = {\n                type: \"polygon\",\n                left: aabb.left,\n                top: aabb.top,\n                right: aabb.right,\n                bottom: aabb.bottom,\n                polygon: convexPolygon,\n                properties: properties || {},\n                collideWidth: function collideWidth(body) {\n                    var sprite = body.sprite;\n                    var spritePosition = new _Vector2.default(sprite.x, sprite.y);\n                    var bodyLeft = body.x;\n                    var bodyRight = body.x + body.width;\n                    var bodyTop = body.y;\n                    var bodyBottom = body.y + body.height;\n\n                    var axes = void 0;\n\n                    var spritePolygon = void 0;\n                    if (body.plus && body.plus.shape) {\n                        spritePolygon = body.plus.shape.translated(spritePosition);\n\n                        // sat axes - more complex shape - all edge normals\n                        axes = spritePolygon.normals.concat(this.polygon.normals);\n                    } else {\n                        spritePolygon = _ConvexPolygon2.default.fromRectangle(bodyLeft, bodyTop, bodyRight, bodyBottom);\n\n                        // sat axes - 2 ortho axis normals and object poly normals\n                        // first 2 normals prune search when sprite out of object bounding box\n                        axes = [new _Vector2.default(1, 0), new _Vector2.default(0, 1)].concat(this.polygon.normals);\n                    }\n\n                    var minPenetration = Number.POSITIVE_INFINITY;\n                    var minNormal = void 0;\n                    var _iteratorNormalCompletion3 = true;\n                    var _didIteratorError3 = false;\n                    var _iteratorError3 = undefined;\n\n                    try {\n                        for (var _iterator3 = axes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                            var axis = _step3.value;\n\n                            var objectRange = this.polygon.projectOntoAxis(axis);\n                            var spriteRange = spritePolygon.projectOntoAxis(axis);\n                            var intersection = _Range2.default.intersection(objectRange, spriteRange);\n                            if (intersection.isEmpty()) {\n                                return null;\n                            }\n\n                            // intersection.length() not good enough for small objects\n                            // need to compute min of two potential penetrations from opposite sides\n                            var penetration = Math.min(Math.abs(objectRange.max - spriteRange.min), Math.abs(spriteRange.max - objectRange.min));\n                            if (minPenetration > penetration) {\n                                minPenetration = penetration;\n                                minNormal = axis;\n                            }\n                        }\n\n                        // ensure normal pointing towards sprite\n                    } catch (err) {\n                        _didIteratorError3 = true;\n                        _iteratorError3 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                                _iterator3.return();\n                            }\n                        } finally {\n                            if (_didIteratorError3) {\n                                throw _iteratorError3;\n                            }\n                        }\n                    }\n\n                    var spriteOffset = spritePolygon.centre.minus(this.polygon.centre);\n                    if (spriteOffset.dot(minNormal) < 0) {\n                        minNormal = minNormal.scale(-1);\n                    }\n\n                    var collision = {\n                        penetration: minNormal.scale(-minPenetration),\n                        normal: minNormal\n                    };\n\n                    return collision;\n                }\n            };\n            this.shapes.push(shape);\n        }\n    }]);\n\n    return ShapeLayer;\n}();\n\nexports.default = ShapeLayer;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdGlsZW1hcC1wbHVzL2dlb21ldHJ5L1NoYXBlTGF5ZXIuanM/Y2IwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVmVjdG9yIGZyb20gXCIuL1ZlY3RvclwiO1xyXG5pbXBvcnQgQ29udmV4UG9seWdvbiBmcm9tIFwiLi9Db252ZXhQb2x5Z29uXCI7XHJcbmltcG9ydCBSYW5nZSBmcm9tIFwiLi9SYW5nZVwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi9BQUJCXCI7XHJcbmltcG9ydCBRdWFkVHJlZSBmcm9tIFwiLi9RdWFkVHJlZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhcGVMYXllciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvYmplY3RMYXllckpzb24pIHtcclxuICAgICAgICB0aGlzLm9iamVjdExheWVySnNvbiA9IG9iamVjdExheWVySnNvbjtcclxuXHJcbiAgICAgICAgdGhpcy5zaGFwZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IG9iamVjdEpzb24gb2Ygb2JqZWN0TGF5ZXJKc29uLm9iamVjdHMpIHtcclxuICAgICAgICAgICAgaWYgKG9iamVjdEpzb24ucG9seWdvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQb2x5Z29uKG9iamVjdEpzb24pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iamVjdEpzb24ucG9seWxpbmUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBwb2x5IGxpbmVcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvYmplY3RKc29uLmVsbGlwc2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBlbGxpcHNlXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0SnNvbi5naWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB0aWxlXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0SnNvbi50ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdGV4dFxyXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyByZWN0YW5nbGVcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUmVjdGFuZ2xlKG9iamVjdEpzb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnF1YWRUcmVlID0gbmV3IFF1YWRUcmVlKHRoaXMuc2hhcGVzLCA1LCA1KTsgICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIGFkZFJlY3RhbmdsZShvYmplY3RKc29uKSB7XHJcbiAgICAgICAgLy8gY29udmVydCB0byBjb252ZXggcG9seWdvblxyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gb2JqZWN0SnNvbi53aWR0aDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBvYmplY3RKc29uLmhlaWdodDtcclxuICAgICAgICBsZXQgd2lkdGhWZWN0b3IgPSBuZXcgVmVjdG9yKHdpZHRoLCAwKTtcclxuICAgICAgICBsZXQgaGVpZ2h0VmVjdG9yID0gbmV3IFZlY3RvcigwLCBoZWlnaHQpO1xyXG4gICAgICAgIC8vIGhhbmRsZSBib3ggcm90YXRpb25cclxuICAgICAgICBjb25zdCBhbmdsZSA9IC1vYmplY3RKc29uLnJvdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgICBpZiAoYW5nbGUpIHtcclxuICAgICAgICAgICAgd2lkdGhWZWN0b3IgPSB3aWR0aFZlY3Rvci5yb3RhdGVkKGFuZ2xlKTtcclxuICAgICAgICAgICAgaGVpZ2h0VmVjdG9yID0gaGVpZ2h0VmVjdG9yLnJvdGF0ZWQoYW5nbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwb2x5Z29uSnNvbiA9IHtcclxuICAgICAgICAgICAgeDogb2JqZWN0SnNvbi54LFxyXG4gICAgICAgICAgICB5OiBvYmplY3RKc29uLnksXHJcbiAgICAgICAgICAgIHdpZHRoOiBvYmplY3RKc29uLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IG9iamVjdEpzb24uaGVpZ2h0LFxyXG4gICAgICAgICAgICBwb2x5Z29uOiBbe3g6IDAsIHk6IDB9LCB3aWR0aFZlY3Rvciwgd2lkdGhWZWN0b3IucGx1cyhoZWlnaHRWZWN0b3IpLCBoZWlnaHRWZWN0b3JdLFxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBvYmplY3RKc29uLnByb3BlcnRpZXMgfHwge31cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYWRkUG9seWdvbihwb2x5Z29uSnNvbik7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkUG9seWdvbihvYmplY3RKc29uKSB7XHJcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBvYmplY3RKc29uLnBvbHlnb24ubWFwKFxyXG4gICAgICAgICAgICBwb2ludCA9PiBuZXcgVmVjdG9yKG9iamVjdEpzb24ueCArIHBvaW50LngsIG9iamVjdEpzb24ueSArIHBvaW50LnkpXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBjb252ZXhQb2x5Z29ucyA9IENvbnZleFBvbHlnb24uZ2VuZXJhdGVDb252ZXhQb2x5Z29ucyh2ZXJ0aWNlcyk7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb252ZXhQb2x5Z29uIG9mIGNvbnZleFBvbHlnb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ29udmV4UG9seWdvbihjb252ZXhQb2x5Z29uLCBvYmplY3RKc29uLnByb3BlcnRpZXMgfHwge30pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhZGRDb252ZXhQb2x5Z29uKGNvbnZleFBvbHlnb24sIHByb3BlcnRpZXMpIHtcclxuICAgICAgICBjb25zdCBhYWJiID0gY29udmV4UG9seWdvbi5hYWJiO1xyXG5cclxuICAgICAgICBjb25zdCBzaGFwZSA9IHsgICAgICAgICAgICBcclxuICAgICAgICAgICAgdHlwZTogXCJwb2x5Z29uXCIsXHJcbiAgICAgICAgICAgIGxlZnQ6IGFhYmIubGVmdCxcclxuICAgICAgICAgICAgdG9wOiBhYWJiLnRvcCxcclxuICAgICAgICAgICAgcmlnaHQ6IGFhYmIucmlnaHQsXHJcbiAgICAgICAgICAgIGJvdHRvbTogYWFiYi5ib3R0b20sXHJcbiAgICAgICAgICAgIHBvbHlnb246IGNvbnZleFBvbHlnb24sXHJcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMgfHwge30sXHJcbiAgICAgICAgICAgIGNvbGxpZGVXaWR0aDogZnVuY3Rpb24oYm9keSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ByaXRlID0gYm9keS5zcHJpdGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcHJpdGVQb3NpdGlvbiA9IG5ldyBWZWN0b3Ioc3ByaXRlLngsIHNwcml0ZS55KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlMZWZ0ID0gYm9keS54O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm9keVJpZ2h0ID0gYm9keS54ICsgYm9keS53aWR0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlUb3AgPSBib2R5Lnk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5Qm90dG9tID0gYm9keS55ICsgYm9keS5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGF4ZXM7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHNwcml0ZVBvbHlnb247XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keS5wbHVzICYmIGJvZHkucGx1cy5zaGFwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZVBvbHlnb24gPSBib2R5LnBsdXMuc2hhcGUudHJhbnNsYXRlZChzcHJpdGVQb3NpdGlvbik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNhdCBheGVzIC0gbW9yZSBjb21wbGV4IHNoYXBlIC0gYWxsIGVkZ2Ugbm9ybWFsc1xyXG4gICAgICAgICAgICAgICAgICAgIGF4ZXMgPSBzcHJpdGVQb2x5Z29uLm5vcm1hbHMuY29uY2F0KHRoaXMucG9seWdvbi5ub3JtYWxzKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlUG9seWdvbiA9IENvbnZleFBvbHlnb24uZnJvbVJlY3RhbmdsZShib2R5TGVmdCwgYm9keVRvcCwgYm9keVJpZ2h0LCBib2R5Qm90dG9tKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2F0IGF4ZXMgLSAyIG9ydGhvIGF4aXMgbm9ybWFscyBhbmQgb2JqZWN0IHBvbHkgbm9ybWFsc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IDIgbm9ybWFscyBwcnVuZSBzZWFyY2ggd2hlbiBzcHJpdGUgb3V0IG9mIG9iamVjdCBib3VuZGluZyBib3hcclxuICAgICAgICAgICAgICAgICAgICBheGVzID0gW25ldyBWZWN0b3IoMSwgMCksIG5ldyBWZWN0b3IoMCwgMSldLmNvbmNhdCh0aGlzLnBvbHlnb24ubm9ybWFscyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IG1pblBlbmV0cmF0aW9uID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgICAgICAgICAgICAgbGV0IG1pbk5vcm1hbDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXhpcyBvZiBheGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0UmFuZ2UgPSB0aGlzLnBvbHlnb24ucHJvamVjdE9udG9BeGlzKGF4aXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwcml0ZVJhbmdlID0gc3ByaXRlUG9seWdvbi5wcm9qZWN0T250b0F4aXMoYXhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uID0gUmFuZ2UuaW50ZXJzZWN0aW9uKG9iamVjdFJhbmdlLCBzcHJpdGVSYW5nZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbi5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcnNlY3Rpb24ubGVuZ3RoKCkgbm90IGdvb2QgZW5vdWdoIGZvciBzbWFsbCBvYmplY3RzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBjb21wdXRlIG1pbiBvZiB0d28gcG90ZW50aWFsIHBlbmV0cmF0aW9ucyBmcm9tIG9wcG9zaXRlIHNpZGVzXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBlbmV0cmF0aW9uID0gTWF0aC5taW4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKG9iamVjdFJhbmdlLm1heCAtIHNwcml0ZVJhbmdlLm1pbiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHNwcml0ZVJhbmdlLm1heCAtIG9iamVjdFJhbmdlLm1pbikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5QZW5ldHJhdGlvbiA+IHBlbmV0cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblBlbmV0cmF0aW9uID0gcGVuZXRyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbk5vcm1hbCA9IGF4aXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgbm9ybWFsIHBvaW50aW5nIHRvd2FyZHMgc3ByaXRlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcHJpdGVPZmZzZXQgPSBzcHJpdGVQb2x5Z29uLmNlbnRyZS5taW51cyh0aGlzLnBvbHlnb24uY2VudHJlKTtcclxuICAgICAgICAgICAgICAgIGlmIChzcHJpdGVPZmZzZXQuZG90KG1pbk5vcm1hbCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluTm9ybWFsID0gbWluTm9ybWFsLnNjYWxlKC0xKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsaXNpb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGVuZXRyYXRpb246IG1pbk5vcm1hbC5zY2FsZSgtbWluUGVuZXRyYXRpb24pLFxyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbDogbWluTm9ybWFsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xsaXNpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc2hhcGVzLnB1c2goc2hhcGUpO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy90aWxlbWFwLXBsdXMvZ2VvbWV0cnkvU2hhcGVMYXllci5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBSUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQW1CQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBSkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUtBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBekJBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUEwQkE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTdDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUE2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBakVBO0FBbUVBO0FBQ0E7Ozs7OztBQWhJQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/*!*******************************************!*\
  !*** ./tilemap-plus/geometry/QuadTree.js ***!
  \*******************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Vector = __webpack_require__(/*! ./Vector */ 0);\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nvar _AABB = __webpack_require__(/*! ./AABB */ 1);\n\nvar _AABB2 = _interopRequireDefault(_AABB);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar QuadTree = function () {\n    function QuadTree(shapes, maxLevel, maxShapes) {\n        _classCallCheck(this, QuadTree);\n\n        this.maxLevel = maxLevel;\n        this.maxShapes = maxShapes;\n        if (shapes.length < maxShapes || maxLevel <= 1) {\n            this.shapes = shapes;\n        } else {\n            var shapesAABB = _AABB2.default.fromAABBs(shapes.map(function (shape) {\n                return shape.polygon.aabb;\n            }));\n            var pivot = shapesAABB.centre();\n            this.pivot = pivot;\n            var straddling = [],\n                topLeft = [],\n                topRight = [],\n                bottomLeft = [],\n                bottomRight = [];\n            // this node contains all shapes straddling pivot axes\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = shapes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var shape = _step.value;\n\n                    var aabb = shape.polygon.aabb;\n                    if (aabb.right < pivot.x && aabb.bottom < pivot.y) {\n                        topLeft.push(shape);\n                    } else if (aabb.left > pivot.x && aabb.bottom < pivot.y) {\n                        topRight.push(shape);\n                    } else if (aabb.right < pivot.x && aabb.top > pivot.y) {\n                        bottomLeft.push(shape);\n                    } else if (aabb.left > pivot.x && aabb.top > pivot.y) {\n                        bottomRight.push(shape);\n                    } else {\n                        straddling.push(shape);\n                    }\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            this.shapes = straddling;\n\n            if (topLeft.length > 0) {\n                this.topLeftNode = new QuadTree(topLeft, maxLevel - 1, maxShapes);\n            }\n\n            if (topRight.length > 0) {\n                this.topRightNode = new QuadTree(topRight, maxLevel - 1, maxShapes);\n            }\n\n            if (bottomLeft.length > 0) {\n                this.bottomLeftNode = new QuadTree(bottomLeft, maxLevel - 1, maxShapes);\n            }\n\n            if (bottomRight.length > 0) {\n                this.bottomRightNode = new QuadTree(bottomRight, maxLevel - 1, maxShapes);\n            }\n        }\n    }\n\n    _createClass(QuadTree, [{\n        key: \"candidateShapes\",\n        value: function candidateShapes(aabb) {\n            // check straddling\n            var result = this.shapes.filter(function (shape) {\n                return shape.polygon.aabb.intersects(aabb);\n            });\n\n            var pivot = this.pivot;\n\n            // nothing else to check if leaf node\n            if (!pivot) {\n                return result;\n            }\n\n            var topLeftNode = this.topLeftNode;\n            if (topLeftNode && aabb.left <= pivot.x && aabb.top <= pivot.y) {\n                // if aabb intersects top left node and it exists, recurse\n                result = result.concat(topLeftNode.candidateShapes(aabb));\n            }\n\n            var topRightNode = this.topRightNode;\n            if (topRightNode && aabb.right >= pivot.x && aabb.top <= pivot.y) {\n                // if aabb intersects top right node and it exists, recurse\n                result = result.concat(topRightNode.candidateShapes(aabb));\n            }\n\n            var bottomLeftNode = this.bottomLeftNode;\n            if (bottomLeftNode && aabb.left <= pivot.x && aabb.bottom >= pivot.y) {\n                // if aabb intersects bottom left node and it exists, recurse\n                result = result.concat(bottomLeftNode.candidateShapes(aabb));\n            }\n\n            var bottomRightNode = this.bottomRightNode;\n            if (bottomRightNode && aabb.right >= pivot.x && aabb.bottom >= pivot.y) {\n                // if aabb intersects bottom right node and it exists, recurse\n                result = result.concat(bottomRightNode.candidateShapes(aabb));\n            }\n\n            return result;\n        }\n    }]);\n\n    return QuadTree;\n}();\n\nexports.default = QuadTree;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3RpbGVtYXAtcGx1cy9nZW9tZXRyeS9RdWFkVHJlZS5qcz8wY2E5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWZWN0b3IgZnJvbSBcIi4vVmVjdG9yXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuL0FBQkJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YWRUcmVlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNoYXBlcywgbWF4TGV2ZWwsIG1heFNoYXBlcykge1xyXG4gICAgICAgIHRoaXMubWF4TGV2ZWwgPSBtYXhMZXZlbDtcclxuICAgICAgICB0aGlzLm1heFNoYXBlcyA9IG1heFNoYXBlcztcclxuICAgICAgICBpZiAoc2hhcGVzLmxlbmd0aCA8IG1heFNoYXBlcyB8fCBtYXhMZXZlbCA8PSAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhcGVzID0gc2hhcGVzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlc0FBQkIgPSBBQUJCLmZyb21BQUJCcyhzaGFwZXMubWFwKHNoYXBlID0+IHNoYXBlLnBvbHlnb24uYWFiYikpO1xyXG4gICAgICAgICAgICBjb25zdCBwaXZvdCA9IHNoYXBlc0FBQkIuY2VudHJlKCkgXHJcbiAgICAgICAgICAgIHRoaXMucGl2b3QgPSBwaXZvdDtcclxuICAgICAgICAgICAgbGV0IHN0cmFkZGxpbmcgPSBbXSwgdG9wTGVmdCA9IFtdLCB0b3BSaWdodCA9IFtdLCBib3R0b21MZWZ0ID0gW10sIGJvdHRvbVJpZ2h0ID0gW107XHJcbiAgICAgICAgICAgIC8vIHRoaXMgbm9kZSBjb250YWlucyBhbGwgc2hhcGVzIHN0cmFkZGxpbmcgcGl2b3QgYXhlc1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNoYXBlIG9mIHNoYXBlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWFiYiA9IHNoYXBlLnBvbHlnb24uYWFiYjtcclxuICAgICAgICAgICAgICAgIGlmIChhYWJiLnJpZ2h0IDwgcGl2b3QueCAmJiBhYWJiLmJvdHRvbSA8IHBpdm90LnkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3BMZWZ0LnB1c2goc2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhYWJiLmxlZnQgPiBwaXZvdC54ICYmIGFhYmIuYm90dG9tIDwgcGl2b3QueSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcFJpZ2h0LnB1c2goc2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhYWJiLnJpZ2h0IDwgcGl2b3QueCAmJiBhYWJiLnRvcCA+IHBpdm90LnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBib3R0b21MZWZ0LnB1c2goc2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhYWJiLmxlZnQgPiBwaXZvdC54ICYmIGFhYmIudG9wID4gcGl2b3QueSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0LnB1c2goc2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJhZGRsaW5nLnB1c2goc2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNoYXBlcyA9IHN0cmFkZGxpbmc7XHJcblxyXG4gICAgICAgICAgICBpZiAodG9wTGVmdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvcExlZnROb2RlID0gbmV3IFF1YWRUcmVlKHRvcExlZnQsIG1heExldmVsIC0gMSwgbWF4U2hhcGVzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRvcFJpZ2h0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudG9wUmlnaHROb2RlID0gbmV3IFF1YWRUcmVlKHRvcFJpZ2h0LCBtYXhMZXZlbCAtIDEsIG1heFNoYXBlcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChib3R0b21MZWZ0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm90dG9tTGVmdE5vZGUgPSBuZXcgUXVhZFRyZWUoYm90dG9tTGVmdCwgbWF4TGV2ZWwgLSAxLCBtYXhTaGFwZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYm90dG9tUmlnaHQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib3R0b21SaWdodE5vZGUgPSBuZXcgUXVhZFRyZWUoYm90dG9tUmlnaHQsIG1heExldmVsIC0gMSwgbWF4U2hhcGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjYW5kaWRhdGVTaGFwZXMoYWFiYikge1xyXG4gICAgICAgIC8vIGNoZWNrIHN0cmFkZGxpbmdcclxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zaGFwZXMuZmlsdGVyKHNoYXBlID0+IHNoYXBlLnBvbHlnb24uYWFiYi5pbnRlcnNlY3RzKGFhYmIpKTtcclxuXHJcbiAgICAgICAgY29uc3QgcGl2b3QgPSB0aGlzLnBpdm90O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIG5vdGhpbmcgZWxzZSB0byBjaGVjayBpZiBsZWFmIG5vZGVcclxuICAgICAgICBpZiAoIXBpdm90KSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0b3BMZWZ0Tm9kZSA9IHRoaXMudG9wTGVmdE5vZGU7XHJcbiAgICAgICAgaWYgKHRvcExlZnROb2RlICYmIGFhYmIubGVmdCA8PSBwaXZvdC54ICYmIGFhYmIudG9wIDw9IHBpdm90LnkpIHtcclxuICAgICAgICAgICAgLy8gaWYgYWFiYiBpbnRlcnNlY3RzIHRvcCBsZWZ0IG5vZGUgYW5kIGl0IGV4aXN0cywgcmVjdXJzZVxyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRvcExlZnROb2RlLmNhbmRpZGF0ZVNoYXBlcyhhYWJiKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0b3BSaWdodE5vZGUgPSB0aGlzLnRvcFJpZ2h0Tm9kZTtcclxuICAgICAgICBpZiAodG9wUmlnaHROb2RlICYmIGFhYmIucmlnaHQgPj0gcGl2b3QueCAmJiBhYWJiLnRvcCA8PSBwaXZvdC55KSB7XHJcbiAgICAgICAgICAgIC8vIGlmIGFhYmIgaW50ZXJzZWN0cyB0b3AgcmlnaHQgbm9kZSBhbmQgaXQgZXhpc3RzLCByZWN1cnNlXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodG9wUmlnaHROb2RlLmNhbmRpZGF0ZVNoYXBlcyhhYWJiKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBib3R0b21MZWZ0Tm9kZSA9IHRoaXMuYm90dG9tTGVmdE5vZGU7XHJcbiAgICAgICAgaWYgKGJvdHRvbUxlZnROb2RlICYmIGFhYmIubGVmdCA8PSBwaXZvdC54ICYmIGFhYmIuYm90dG9tID49IHBpdm90LnkpIHtcclxuICAgICAgICAgICAgLy8gaWYgYWFiYiBpbnRlcnNlY3RzIGJvdHRvbSBsZWZ0IG5vZGUgYW5kIGl0IGV4aXN0cywgcmVjdXJzZVxyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGJvdHRvbUxlZnROb2RlLmNhbmRpZGF0ZVNoYXBlcyhhYWJiKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBib3R0b21SaWdodE5vZGUgPSB0aGlzLmJvdHRvbVJpZ2h0Tm9kZTtcclxuICAgICAgICBpZiAoYm90dG9tUmlnaHROb2RlICYmIGFhYmIucmlnaHQgPj0gcGl2b3QueCAmJiBhYWJiLmJvdHRvbSA+PSBwaXZvdC55KSB7XHJcbiAgICAgICAgICAgIC8vIGlmIGFhYmIgaW50ZXJzZWN0cyBib3R0b20gcmlnaHQgbm9kZSBhbmQgaXQgZXhpc3RzLCByZWN1cnNlXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoYm90dG9tUmlnaHROb2RlLmNhbmRpZGF0ZVNoYXBlcyhhYWJiKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy90aWxlbWFwLXBsdXMvZ2VvbWV0cnkvUXVhZFRyZWUuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7OztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFMQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBTUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBbkZBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/*!***************************************!*\
  !*** ./tilemap-plus/events/Events.js ***!
  \***************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _CollisionEvents = __webpack_require__(/*! ./CollisionEvents */ 12);\n\nvar _CollisionEvents2 = _interopRequireDefault(_CollisionEvents);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Events = function Events() {\n    _classCallCheck(this, Events);\n\n    this.collisions = new _CollisionEvents2.default();\n};\n\nexports.default = Events;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3RpbGVtYXAtcGx1cy9ldmVudHMvRXZlbnRzLmpzP2UzNTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbGxpc2lvbkV2ZW50cyBmcm9tIFwiLi9Db2xsaXNpb25FdmVudHNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50cyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmNvbGxpc2lvbnMgPSBuZXcgQ29sbGlzaW9uRXZlbnRzKCk7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RpbGVtYXAtcGx1cy9ldmVudHMvRXZlbnRzLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/*!************************************************!*\
  !*** ./tilemap-plus/events/CollisionEvents.js ***!
  \************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar CollisionEvents = function () {\n    function CollisionEvents() {\n        _classCallCheck(this, CollisionEvents);\n\n        this.spriteListeners = new Map();\n        this.spriteCollisions = new Map();\n    }\n\n    _createClass(CollisionEvents, [{\n        key: \"add\",\n        value: function add(sprite, listener) {\n            var listeners = this.getSpriteListeners(sprite);\n            listeners.push(listener);\n        }\n    }, {\n        key: \"remove\",\n        value: function remove(sprite, listener) {\n            var listeners = this.getSpriteListeners(sprite);\n            this.spriteListeners.set(sprite, listeners.filter(function (l) {\n                return l != listener;\n            }));\n        }\n    }, {\n        key: \"notify\",\n        value: function notify(sprite, shapes, oldVelocity, newVelocity, contactNormal) {\n            var prevShapes = this.spriteCollisions.has(sprite) ? this.spriteCollisions.get(sprite) : [];\n            var newShapes = shapes.filter(function (shape) {\n                return !prevShapes.find(function (prevShape) {\n                    return prevShape === shape;\n                });\n            });\n            this.spriteCollisions.set(sprite, shapes);\n\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = newShapes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var newShape = _step.value;\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n\n                    try {\n                        for (var _iterator2 = this.getSpriteListeners(sprite)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                            var listener = _step2.value;\n\n                            listener(newShape, oldVelocity, newVelocity, contactNormal);\n                        }\n                    } catch (err) {\n                        _didIteratorError2 = true;\n                        _iteratorError2 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                _iterator2.return();\n                            }\n                        } finally {\n                            if (_didIteratorError2) {\n                                throw _iteratorError2;\n                            }\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"getSpriteListeners\",\n        value: function getSpriteListeners(sprite) {\n            if (!this.spriteListeners.has(sprite)) {\n                this.spriteListeners.set(sprite, []);\n            }\n            return this.spriteListeners.get(sprite);\n        }\n    }]);\n\n    return CollisionEvents;\n}();\n\nexports.default = CollisionEvents;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3RpbGVtYXAtcGx1cy9ldmVudHMvQ29sbGlzaW9uRXZlbnRzLmpzP2Q2YjIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sbGlzaW9uRXZlbnRzIHtcclxuICAgIGNvbnN0cnVjdG9yICgpIHtcclxuICAgICAgICB0aGlzLnNwcml0ZUxpc3RlbmVycyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLnNwcml0ZUNvbGxpc2lvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkKHNwcml0ZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmdldFNwcml0ZUxpc3RlbmVycyhzcHJpdGUpO1xyXG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuICAgIH1cclxuXHJcbiAgICByZW1vdmUoc3ByaXRlLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuZ2V0U3ByaXRlTGlzdGVuZXJzKHNwcml0ZSk7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVMaXN0ZW5lcnMuc2V0KHNwcml0ZSwgbGlzdGVuZXJzLmZpbHRlcihsID0+IGwgIT0gbGlzdGVuZXIpKTtcclxuICAgIH1cclxuXHJcbiAgICBub3RpZnkoc3ByaXRlLCBzaGFwZXMsIG9sZFZlbG9jaXR5LCBuZXdWZWxvY2l0eSwgY29udGFjdE5vcm1hbCkge1xyXG4gICAgICAgIGNvbnN0IHByZXZTaGFwZXMgPSB0aGlzLnNwcml0ZUNvbGxpc2lvbnMuaGFzKHNwcml0ZSkgPyB0aGlzLnNwcml0ZUNvbGxpc2lvbnMuZ2V0KHNwcml0ZSkgOiBbXTtcclxuICAgICAgICBjb25zdCBuZXdTaGFwZXMgPSBzaGFwZXMuZmlsdGVyKHNoYXBlID0+XHJcbiAgICAgICAgICAgICFwcmV2U2hhcGVzLmZpbmQocHJldlNoYXBlID0+IHByZXZTaGFwZSA9PT0gc2hhcGUpXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLnNwcml0ZUNvbGxpc2lvbnMuc2V0KHNwcml0ZSwgc2hhcGVzKTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBuZXdTaGFwZSBvZiBuZXdTaGFwZXMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmdldFNwcml0ZUxpc3RlbmVycyhzcHJpdGUpKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihuZXdTaGFwZSwgb2xkVmVsb2NpdHksIG5ld1ZlbG9jaXR5LCBjb250YWN0Tm9ybWFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U3ByaXRlTGlzdGVuZXJzKHNwcml0ZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5zcHJpdGVMaXN0ZW5lcnMuaGFzKHNwcml0ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVMaXN0ZW5lcnMuc2V0KHNwcml0ZSwgW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zcHJpdGVMaXN0ZW5lcnMuZ2V0KHNwcml0ZSk7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RpbGVtYXAtcGx1cy9ldmVudHMvQ29sbGlzaW9uRXZlbnRzLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFHQTtBQUNBO0FBTkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQU9BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQVhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFZQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFuQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/*!******************************************!*\
  !*** ./tilemap-plus/TilemapLayerPlus.js ***!
  \******************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TilemapLayerPlus = function TilemapLayerPlus(tilemapLayer) {\n    _classCallCheck(this, TilemapLayerPlus);\n\n    this.properties = tilemapLayer.layer.properties || {};\n};\n\nexports.default = TilemapLayerPlus;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3RpbGVtYXAtcGx1cy9UaWxlbWFwTGF5ZXJQbHVzLmpzP2QyODciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZW1hcExheWVyUGx1cyB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0aWxlbWFwTGF5ZXIpIHtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB0aWxlbWFwTGF5ZXIubGF5ZXIucHJvcGVydGllcyB8fCB7fTtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvdGlsZW1hcC1wbHVzL1RpbGVtYXBMYXllclBsdXMuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/*!*************************************!*\
  !*** ./tilemap-plus/TilesetPlus.js ***!
  \*************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TilesetPlus = function TilesetPlus(tileset) {\n    _classCallCheck(this, TilesetPlus);\n\n    this.properties = tileset.properties || {};\n};\n\nexports.default = TilesetPlus;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3RpbGVtYXAtcGx1cy9UaWxlc2V0UGx1cy5qcz8yZjEwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGVzZXRQbHVzIHtcclxuICAgIGNvbnN0cnVjdG9yKHRpbGVzZXQpIHtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB0aWxlc2V0LnByb3BlcnRpZXMgfHwge307XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RpbGVtYXAtcGx1cy9UaWxlc2V0UGx1cy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFKQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/*!************************************!*\
  !*** ./tilemap-plus/SpritePlus.js ***!
  \************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ConvexPolygon = __webpack_require__(/*! ./geometry/ConvexPolygon */ 2);\n\nvar _ConvexPolygon2 = _interopRequireDefault(_ConvexPolygon);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SpritePlus = function () {\n    function SpritePlus(sprite) {\n        _classCallCheck(this, SpritePlus);\n\n        this.sprite = sprite;\n    }\n\n    _createClass(SpritePlus, [{\n        key: \"setBodyCapsule\",\n        value: function setBodyCapsule(width, height, segments) {\n            var sprite = this.sprite;\n            if (sprite.body) {\n                var body = sprite.body;\n                body.plus = body.plus || {};\n                var halfWidth = width * 0.5;\n                var halfHeight = height * 0.5;\n                body.plus.shape = _ConvexPolygon2.default.fromCapsule(-halfWidth, -halfHeight, +halfWidth, +halfHeight, segments);\n            } else {\n                throw new Error(\"Enable arcade physics before assigning body shape\");\n            }\n        }\n    }]);\n\n    return SpritePlus;\n}();\n\nexports.default = SpritePlus;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3RpbGVtYXAtcGx1cy9TcHJpdGVQbHVzLmpzPzM0ZTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbnZleFBvbHlnb24gZnJvbSBcIi4vZ2VvbWV0cnkvQ29udmV4UG9seWdvblwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ByaXRlUGx1cyB7XHJcbiAgICBjb25zdHJ1Y3RvcihzcHJpdGUpIHtcclxuICAgICAgICB0aGlzLnNwcml0ZSA9IHNwcml0ZTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRCb2R5Q2Fwc3VsZSh3aWR0aCwgaGVpZ2h0LCBzZWdtZW50cykge1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZSA9IHRoaXMuc3ByaXRlO1xyXG4gICAgICAgIGlmIChzcHJpdGUuYm9keSkge1xyXG4gICAgICAgICAgICBjb25zdCBib2R5ID0gc3ByaXRlLmJvZHk7XHJcbiAgICAgICAgICAgIGJvZHkucGx1cyA9IGJvZHkucGx1cyB8fCB7fTtcclxuICAgICAgICAgICAgY29uc3QgaGFsZldpZHRoID0gd2lkdGggKiAwLjU7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbGZIZWlnaHQgPSBoZWlnaHQgKiAwLjU7XHJcbiAgICAgICAgICAgIGJvZHkucGx1cy5zaGFwZSA9IENvbnZleFBvbHlnb24uZnJvbUNhcHN1bGUoXHJcbiAgICAgICAgICAgICAgICAtaGFsZldpZHRoLCAtaGFsZkhlaWdodCwgK2hhbGZXaWR0aCwgK2hhbGZIZWlnaHQsIHNlZ21lbnRzXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5hYmxlIGFyY2FkZSBwaHlzaWNzIGJlZm9yZSBhc3NpZ25pbmcgYm9keSBzaGFwZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3RpbGVtYXAtcGx1cy9TcHJpdGVQbHVzLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFsQkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n");

/***/ })
/******/ ]);